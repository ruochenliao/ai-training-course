# 工具函数还原提示词

## 服务概述

智能客服工具函数系统提供了一套完整的客服业务工具集，通过统一的API调用接口与后端业务系统集成，支持产品查询、订单管理、促销活动、政策查询、退货处理等核心客服功能，为AI智能体提供强大的业务处理能力。

## 技术栈要求

```json
{
  "language": "Python 3.9+",
  "http_client": "aiohttp",
  "async_support": "asyncio",
  "json_handling": "json",
  "logging": "Python logging",
  "error_handling": "try-catch with detailed logging",
  "type_hints": "typing module",
  "validation": "parameter validation"
}
```

## 核心架构设计

### 1. 工具函数主模块

```python
# 文件路径: c_app/services/agent_tools.py
import json
import logging
import asyncio
from typing import Dict, Any, List, Optional, Union
from datetime import datetime, timedelta

import aiohttp
from aiohttp import ClientTimeout, ClientError

logger = logging.getLogger(__name__)

# 配置常量
API_BASE_URL = "http://localhost:8080/api"  # 后端业务系统API地址
API_TIMEOUT = 30  # API调用超时时间（秒）
MAX_RETRIES = 3  # 最大重试次数
RETRY_DELAY = 1  # 重试延迟（秒）

class CustomerServiceTools:
    """
    智能客服工具函数集合
    
    提供完整的客服业务工具，包括产品查询、订单管理、促销活动、
    政策查询、退货处理等功能。所有工具都通过统一的API调用接口
    与后端业务系统进行交互。
    """
    
    def __init__(self, api_base_url: str = API_BASE_URL):
        self.api_base_url = api_base_url.rstrip('/')
        self.session = None
        self._setup_logging()
    
    def _setup_logging(self):
        """配置日志记录"""
        self.logger = logging.getLogger(f"{__name__}.{self.__class__.__name__}")
        self.logger.setLevel(logging.INFO)
    
    async def __aenter__(self):
        """异步上下文管理器入口"""
        await self._ensure_session()
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """异步上下文管理器出口"""
        await self._close_session()
    
    async def _ensure_session(self):
        """确保HTTP会话存在"""
        if self.session is None or self.session.closed:
            timeout = ClientTimeout(total=API_TIMEOUT)
            self.session = aiohttp.ClientSession(
                timeout=timeout,
                headers={
                    "Content-Type": "application/json",
                    "User-Agent": "CustomerService-AI-Agent/1.0"
                }
            )
    
    async def _close_session(self):
        """关闭HTTP会话"""
        if self.session and not self.session.closed:
            await self.session.close()
            self.session = None
    
    async def _call_api(
        self,
        endpoint: str,
        method: str = "GET",
        data: Optional[Dict[str, Any]] = None,
        params: Optional[Dict[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None
    ) -> Dict[str, Any]:
        """
        统一的API调用接口
        
        Args:
            endpoint: API端点路径
            method: HTTP方法 (GET, POST, PUT, DELETE)
            data: 请求体数据
            params: URL查询参数
            headers: 额外的请求头
        
        Returns:
            API响应数据字典
        
        Raises:
            Exception: API调用失败时抛出异常
        """
        await self._ensure_session()
        
        url = f"{self.api_base_url}/{endpoint.lstrip('/')}"
        request_headers = headers or {}
        
        # 参数验证
        if method.upper() not in ["GET", "POST", "PUT", "DELETE", "PATCH"]:
            raise ValueError(f"不支持的HTTP方法: {method}")
        
        # 记录请求信息
        self.logger.info(f"API调用开始 - {method.upper()} {url}")
        if data:
            self.logger.debug(f"请求数据: {json.dumps(data, ensure_ascii=False, indent=2)}")
        if params:
            self.logger.debug(f"查询参数: {params}")
        
        # 重试机制
        last_exception = None
        for attempt in range(MAX_RETRIES):
            try:
                # 发送请求
                async with self.session.request(
                    method=method.upper(),
                    url=url,
                    json=data if method.upper() in ["POST", "PUT", "PATCH"] else None,
                    params=params,
                    headers=request_headers
                ) as response:
                    
                    # 记录响应状态
                    self.logger.info(f"API响应状态: {response.status}")
                    
                    # 读取响应内容
                    try:
                        response_text = await response.text()
                        if response_text:
                            response_data = json.loads(response_text)
                        else:
                            response_data = {}
                    except json.JSONDecodeError as e:
                        self.logger.error(f"JSON解析失败: {e}, 响应内容: {response_text[:500]}")
                        response_data = {"error": "响应格式错误", "raw_response": response_text[:500]}
                    
                    # 处理HTTP错误状态
                    if response.status >= 400:
                        error_msg = response_data.get("message", response_data.get("error", f"HTTP {response.status} 错误"))
                        self.logger.error(f"API调用失败: {error_msg}")
                        
                        if response.status >= 500:
                            # 服务器错误，可以重试
                            raise aiohttp.ClientResponseError(
                                request_info=response.request_info,
                                history=response.history,
                                status=response.status,
                                message=error_msg
                            )
                        else:
                            # 客户端错误，不重试
                            return {
                                "success": False,
                                "error": error_msg,
                                "status_code": response.status,
                                "data": response_data
                            }
                    
                    # 成功响应
                    self.logger.info(f"API调用成功 - {method.upper()} {url}")
                    self.logger.debug(f"响应数据: {json.dumps(response_data, ensure_ascii=False, indent=2)}")
                    
                    return {
                        "success": True,
                        "data": response_data,
                        "status_code": response.status
                    }
            
            except (ClientError, asyncio.TimeoutError) as e:
                last_exception = e
                self.logger.warning(f"API调用失败 (尝试 {attempt + 1}/{MAX_RETRIES}): {str(e)}")
                
                if attempt < MAX_RETRIES - 1:
                    await asyncio.sleep(RETRY_DELAY * (attempt + 1))  # 指数退避
                    continue
                else:
                    break
            
            except Exception as e:
                # 其他异常不重试
                self.logger.error(f"API调用异常: {str(e)}", exc_info=True)
                return {
                    "success": False,
                    "error": f"API调用异常: {str(e)}",
                    "exception_type": type(e).__name__
                }
        
        # 所有重试都失败
        error_msg = f"API调用失败，已重试{MAX_RETRIES}次: {str(last_exception)}"
        self.logger.error(error_msg)
        return {
            "success": False,
            "error": error_msg,
            "exception_type": type(last_exception).__name__ if last_exception else "Unknown"
        }


# 全局工具实例
_tools_instance = None

async def get_tools_instance() -> CustomerServiceTools:
    """获取工具实例（单例模式）"""
    global _tools_instance
    if _tools_instance is None:
        _tools_instance = CustomerServiceTools()
        await _tools_instance._ensure_session()
    return _tools_instance


# ==================== 产品相关工具函数 ====================

async def get_product_details(product_id: str) -> Dict[str, Any]:
    """
    获取产品详细信息
    
    根据产品ID获取产品的详细信息，包括名称、价格、库存、规格等。
    
    Args:
        product_id: 产品ID
    
    Returns:
        包含产品详细信息的字典
    
    Example:
        >>> result = await get_product_details("PROD001")
        >>> print(result["data"]["name"])  # 产品名称
    """
    if not product_id or not isinstance(product_id, str):
        return {
            "success": False,
            "error": "产品ID不能为空且必须是字符串类型"
        }
    
    tools = await get_tools_instance()
    
    try:
        result = await tools._call_api(
            endpoint=f"/products/{product_id}",
            method="GET"
        )
        
        if result["success"]:
            # 格式化产品信息
            product_data = result["data"]
            formatted_result = {
                "success": True,
                "data": {
                    "id": product_data.get("id", product_id),
                    "name": product_data.get("name", "未知产品"),
                    "price": product_data.get("price", 0),
                    "currency": product_data.get("currency", "CNY"),
                    "stock": product_data.get("stock", 0),
                    "category": product_data.get("category", ""),
                    "description": product_data.get("description", ""),
                    "specifications": product_data.get("specifications", {}),
                    "images": product_data.get("images", []),
                    "status": product_data.get("status", "unknown"),
                    "created_at": product_data.get("created_at", ""),
                    "updated_at": product_data.get("updated_at", "")
                }
            }
            
            logger.info(f"成功获取产品信息: {product_id}")
            return formatted_result
        else:
            return result
    
    except Exception as e:
        logger.error(f"获取产品详情异常: {str(e)}", exc_info=True)
        return {
            "success": False,
            "error": f"获取产品详情时发生异常: {str(e)}"
        }


async def search_products(
    query: str,
    category: Optional[str] = None,
    min_price: Optional[float] = None,
    max_price: Optional[float] = None,
    limit: int = 10,
    offset: int = 0
) -> Dict[str, Any]:
    """
    搜索产品
    
    根据关键词和筛选条件搜索产品列表。
    
    Args:
        query: 搜索关键词
        category: 产品分类（可选）
        min_price: 最低价格（可选）
        max_price: 最高价格（可选）
        limit: 返回结果数量限制（默认10）
        offset: 结果偏移量（默认0）
    
    Returns:
        包含搜索结果的字典
    
    Example:
        >>> result = await search_products("手机", category="电子产品", max_price=5000)
        >>> products = result["data"]["products"]
    """
    if not query or not isinstance(query, str):
        return {
            "success": False,
            "error": "搜索关键词不能为空且必须是字符串类型"
        }
    
    if limit <= 0 or limit > 100:
        return {
            "success": False,
            "error": "限制数量必须在1-100之间"
        }
    
    if offset < 0:
        return {
            "success": False,
            "error": "偏移量不能为负数"
        }
    
    tools = await get_tools_instance()
    
    # 构建查询参数
    params = {
        "q": query.strip(),
        "limit": limit,
        "offset": offset
    }
    
    if category:
        params["category"] = category
    if min_price is not None:
        params["min_price"] = min_price
    if max_price is not None:
        params["max_price"] = max_price
    
    try:
        result = await tools._call_api(
            endpoint="/products/search",
            method="GET",
            params=params
        )
        
        if result["success"]:
            # 格式化搜索结果
            search_data = result["data"]
            formatted_result = {
                "success": True,
                "data": {
                    "query": query,
                    "total_count": search_data.get("total", 0),
                    "page_info": {
                        "limit": limit,
                        "offset": offset,
                        "has_more": search_data.get("has_more", False)
                    },
                    "filters": {
                        "category": category,
                        "min_price": min_price,
                        "max_price": max_price
                    },
                    "products": [
                        {
                            "id": product.get("id"),
                            "name": product.get("name"),
                            "price": product.get("price"),
                            "currency": product.get("currency", "CNY"),
                            "stock": product.get("stock"),
                            "category": product.get("category"),
                            "image": product.get("images", [{}])[0].get("url", "") if product.get("images") else "",
                            "rating": product.get("rating", 0),
                            "review_count": product.get("review_count", 0)
                        }
                        for product in search_data.get("products", [])
                    ]
                }
            }
            
            logger.info(f"产品搜索成功: 关键词='{query}', 找到{len(formatted_result['data']['products'])}个结果")
            return formatted_result
        else:
            return result
    
    except Exception as e:
        logger.error(f"产品搜索异常: {str(e)}", exc_info=True)
        return {
            "success": False,
            "error": f"产品搜索时发生异常: {str(e)}"
        }


# ==================== 订单相关工具函数 ====================

async def get_order_status(order_id: str) -> Dict[str, Any]:
    """
    获取订单状态
    
    根据订单ID获取订单的当前状态和详细信息。
    
    Args:
        order_id: 订单ID
    
    Returns:
        包含订单状态信息的字典
    
    Example:
        >>> result = await get_order_status("ORD123456")
        >>> status = result["data"]["status"]
    """
    if not order_id or not isinstance(order_id, str):
        return {
            "success": False,
            "error": "订单ID不能为空且必须是字符串类型"
        }
    
    tools = await get_tools_instance()
    
    try:
        result = await tools._call_api(
            endpoint=f"/orders/{order_id}",
            method="GET"
        )
        
        if result["success"]:
            # 格式化订单信息
            order_data = result["data"]
            formatted_result = {
                "success": True,
                "data": {
                    "order_id": order_data.get("id", order_id),
                    "status": order_data.get("status", "unknown"),
                    "status_description": _get_status_description(order_data.get("status")),
                    "customer_id": order_data.get("customer_id", ""),
                    "total_amount": order_data.get("total_amount", 0),
                    "currency": order_data.get("currency", "CNY"),
                    "created_at": order_data.get("created_at", ""),
                    "updated_at": order_data.get("updated_at", ""),
                    "estimated_delivery": order_data.get("estimated_delivery", ""),
                    "tracking_number": order_data.get("tracking_number", ""),
                    "shipping_address": order_data.get("shipping_address", {}),
                    "items": [
                        {
                            "product_id": item.get("product_id"),
                            "product_name": item.get("product_name"),
                            "quantity": item.get("quantity"),
                            "unit_price": item.get("unit_price"),
                            "total_price": item.get("total_price")
                        }
                        for item in order_data.get("items", [])
                    ],
                    "payment_info": {
                        "method": order_data.get("payment_method", ""),
                        "status": order_data.get("payment_status", ""),
                        "transaction_id": order_data.get("transaction_id", "")
                    },
                    "timeline": order_data.get("timeline", [])
                }
            }
            
            logger.info(f"成功获取订单状态: {order_id} - {formatted_result['data']['status']}")
            return formatted_result
        else:
            return result
    
    except Exception as e:
        logger.error(f"获取订单状态异常: {str(e)}", exc_info=True)
        return {
            "success": False,
            "error": f"获取订单状态时发生异常: {str(e)}"
        }


async def cancel_order(order_id: str, reason: str = "") -> Dict[str, Any]:
    """
    取消订单
    
    取消指定的订单，需要提供取消原因。
    
    Args:
        order_id: 订单ID
        reason: 取消原因（可选）
    
    Returns:
        包含取消结果的字典
    
    Example:
        >>> result = await cancel_order("ORD123456", "客户要求取消")
        >>> success = result["success"]
    """
    if not order_id or not isinstance(order_id, str):
        return {
            "success": False,
            "error": "订单ID不能为空且必须是字符串类型"
        }
    
    tools = await get_tools_instance()
    
    # 构建请求数据
    cancel_data = {
        "action": "cancel",
        "reason": reason or "客户申请取消",
        "timestamp": datetime.now().isoformat()
    }
    
    try:
        result = await tools._call_api(
            endpoint=f"/orders/{order_id}/cancel",
            method="POST",
            data=cancel_data
        )
        
        if result["success"]:
            # 格式化取消结果
            cancel_result = result["data"]
            formatted_result = {
                "success": True,
                "data": {
                    "order_id": order_id,
                    "status": "cancelled",
                    "cancel_time": cancel_result.get("cancel_time", datetime.now().isoformat()),
                    "reason": reason,
                    "refund_info": {
                        "amount": cancel_result.get("refund_amount", 0),
                        "method": cancel_result.get("refund_method", ""),
                        "estimated_time": cancel_result.get("refund_estimated_time", "")
                    },
                    "message": cancel_result.get("message", "订单已成功取消")
                }
            }
            
            logger.info(f"订单取消成功: {order_id}, 原因: {reason}")
            return formatted_result
        else:
            return result
    
    except Exception as e:
        logger.error(f"取消订单异常: {str(e)}", exc_info=True)
        return {
            "success": False,
            "error": f"取消订单时发生异常: {str(e)}"
        }


# ==================== 促销活动工具函数 ====================

async def get_active_promotions(
    category: Optional[str] = None,
    product_id: Optional[str] = None
) -> Dict[str, Any]:
    """
    获取当前活跃的促销活动
    
    获取当前正在进行的促销活动列表，可以按分类或产品筛选。
    
    Args:
        category: 产品分类（可选）
        product_id: 特定产品ID（可选）
    
    Returns:
        包含促销活动列表的字典
    
    Example:
        >>> result = await get_active_promotions(category="电子产品")
        >>> promotions = result["data"]["promotions"]
    """
    tools = await get_tools_instance()
    
    # 构建查询参数
    params = {
        "status": "active",
        "current_time": datetime.now().isoformat()
    }
    
    if category:
        params["category"] = category
    if product_id:
        params["product_id"] = product_id
    
    try:
        result = await tools._call_api(
            endpoint="/promotions",
            method="GET",
            params=params
        )
        
        if result["success"]:
            # 格式化促销活动信息
            promotions_data = result["data"]
            formatted_result = {
                "success": True,
                "data": {
                    "total_count": promotions_data.get("total", 0),
                    "filters": {
                        "category": category,
                        "product_id": product_id
                    },
                    "promotions": [
                        {
                            "id": promo.get("id"),
                            "title": promo.get("title", ""),
                            "description": promo.get("description", ""),
                            "type": promo.get("type", ""),  # discount, coupon, bundle等
                            "discount_value": promo.get("discount_value", 0),
                            "discount_type": promo.get("discount_type", ""),  # percentage, fixed
                            "start_time": promo.get("start_time", ""),
                            "end_time": promo.get("end_time", ""),
                            "applicable_products": promo.get("applicable_products", []),
                            "applicable_categories": promo.get("applicable_categories", []),
                            "conditions": promo.get("conditions", {}),
                            "usage_limit": promo.get("usage_limit", 0),
                            "used_count": promo.get("used_count", 0),
                            "coupon_code": promo.get("coupon_code", "")
                        }
                        for promo in promotions_data.get("promotions", [])
                    ]
                }
            }
            
            logger.info(f"成功获取促销活动: 找到{len(formatted_result['data']['promotions'])}个活动")
            return formatted_result
        else:
            return result
    
    except Exception as e:
        logger.error(f"获取促销活动异常: {str(e)}", exc_info=True)
        return {
            "success": False,
            "error": f"获取促销活动时发生异常: {str(e)}"
        }


# ==================== 政策查询工具函数 ====================

async def get_policy(policy_type: str) -> Dict[str, Any]:
    """
    获取公司政策信息
    
    根据政策类型获取相应的政策内容，如退货政策、隐私政策等。
    
    Args:
        policy_type: 政策类型 (return, privacy, shipping, warranty等)
    
    Returns:
        包含政策内容的字典
    
    Example:
        >>> result = await get_policy("return")
        >>> policy_content = result["data"]["content"]
    """
    if not policy_type or not isinstance(policy_type, str):
        return {
            "success": False,
            "error": "政策类型不能为空且必须是字符串类型"
        }
    
    # 支持的政策类型
    supported_policies = [
        "return", "privacy", "shipping", "warranty", 
        "terms", "refund", "exchange", "payment"
    ]
    
    if policy_type.lower() not in supported_policies:
        return {
            "success": False,
            "error": f"不支持的政策类型: {policy_type}。支持的类型: {', '.join(supported_policies)}"
        }
    
    tools = await get_tools_instance()
    
    try:
        result = await tools._call_api(
            endpoint=f"/policies/{policy_type.lower()}",
            method="GET"
        )
        
        if result["success"]:
            # 格式化政策信息
            policy_data = result["data"]
            formatted_result = {
                "success": True,
                "data": {
                    "policy_type": policy_type.lower(),
                    "title": policy_data.get("title", f"{policy_type.title()} Policy"),
                    "content": policy_data.get("content", ""),
                    "summary": policy_data.get("summary", ""),
                    "last_updated": policy_data.get("last_updated", ""),
                    "version": policy_data.get("version", "1.0"),
                    "sections": policy_data.get("sections", []),
                    "contact_info": policy_data.get("contact_info", {}),
                    "effective_date": policy_data.get("effective_date", "")
                }
            }
            
            logger.info(f"成功获取政策信息: {policy_type}")
            return formatted_result
        else:
            return result
    
    except Exception as e:
        logger.error(f"获取政策信息异常: {str(e)}", exc_info=True)
        return {
            "success": False,
            "error": f"获取政策信息时发生异常: {str(e)}"
        }


# ==================== 退货相关工具函数 ====================

async def check_return_eligibility(order_id: str, product_id: str) -> Dict[str, Any]:
    """
    检查退货资格
    
    检查指定订单中的产品是否符合退货条件。
    
    Args:
        order_id: 订单ID
        product_id: 产品ID
    
    Returns:
        包含退货资格检查结果的字典
    
    Example:
        >>> result = await check_return_eligibility("ORD123456", "PROD001")
        >>> eligible = result["data"]["eligible"]
    """
    if not order_id or not isinstance(order_id, str):
        return {
            "success": False,
            "error": "订单ID不能为空且必须是字符串类型"
        }
    
    if not product_id or not isinstance(product_id, str):
        return {
            "success": False,
            "error": "产品ID不能为空且必须是字符串类型"
        }
    
    tools = await get_tools_instance()
    
    try:
        result = await tools._call_api(
            endpoint=f"/returns/check-eligibility",
            method="POST",
            data={
                "order_id": order_id,
                "product_id": product_id,
                "check_time": datetime.now().isoformat()
            }
        )
        
        if result["success"]:
            # 格式化退货资格信息
            eligibility_data = result["data"]
            formatted_result = {
                "success": True,
                "data": {
                    "order_id": order_id,
                    "product_id": product_id,
                    "eligible": eligibility_data.get("eligible", False),
                    "reason": eligibility_data.get("reason", ""),
                    "return_window": {
                        "days_remaining": eligibility_data.get("days_remaining", 0),
                        "deadline": eligibility_data.get("return_deadline", ""),
                        "policy_days": eligibility_data.get("policy_days", 30)
                    },
                    "conditions": eligibility_data.get("conditions", []),
                    "restrictions": eligibility_data.get("restrictions", []),
                    "refund_info": {
                        "refund_amount": eligibility_data.get("refund_amount", 0),
                        "refund_method": eligibility_data.get("refund_method", ""),
                        "processing_time": eligibility_data.get("processing_time", "")
                    },
                    "required_documents": eligibility_data.get("required_documents", []),
                    "return_address": eligibility_data.get("return_address", {})
                }
            }
            
            logger.info(f"退货资格检查完成: 订单{order_id}, 产品{product_id}, 结果: {formatted_result['data']['eligible']}")
            return formatted_result
        else:
            return result
    
    except Exception as e:
        logger.error(f"检查退货资格异常: {str(e)}", exc_info=True)
        return {
            "success": False,
            "error": f"检查退货资格时发生异常: {str(e)}"
        }


async def submit_return_request(
    order_id: str,
    product_id: str,
    reason: str,
    description: str = "",
    images: Optional[List[str]] = None
) -> Dict[str, Any]:
    """
    提交退货申请
    
    为指定的订单和产品提交退货申请。
    
    Args:
        order_id: 订单ID
        product_id: 产品ID
        reason: 退货原因
        description: 详细描述（可选）
        images: 相关图片URL列表（可选）
    
    Returns:
        包含退货申请结果的字典
    
    Example:
        >>> result = await submit_return_request(
        ...     "ORD123456", "PROD001", "产品质量问题", "产品有划痕"
        ... )
        >>> return_id = result["data"]["return_id"]
    """
    if not order_id or not isinstance(order_id, str):
        return {
            "success": False,
            "error": "订单ID不能为空且必须是字符串类型"
        }
    
    if not product_id or not isinstance(product_id, str):
        return {
            "success": False,
            "error": "产品ID不能为空且必须是字符串类型"
        }
    
    if not reason or not isinstance(reason, str):
        return {
            "success": False,
            "error": "退货原因不能为空且必须是字符串类型"
        }
    
    tools = await get_tools_instance()
    
    # 构建退货申请数据
    return_request_data = {
        "order_id": order_id,
        "product_id": product_id,
        "reason": reason.strip(),
        "description": description.strip() if description else "",
        "images": images or [],
        "submit_time": datetime.now().isoformat(),
        "status": "pending"
    }
    
    try:
        result = await tools._call_api(
            endpoint="/returns/submit",
            method="POST",
            data=return_request_data
        )
        
        if result["success"]:
            # 格式化退货申请结果
            return_data = result["data"]
            formatted_result = {
                "success": True,
                "data": {
                    "return_id": return_data.get("return_id", ""),
                    "order_id": order_id,
                    "product_id": product_id,
                    "status": "pending",
                    "submit_time": return_data.get("submit_time", datetime.now().isoformat()),
                    "estimated_processing_time": return_data.get("estimated_processing_time", "3-5个工作日"),
                    "next_steps": return_data.get("next_steps", []),
                    "contact_info": return_data.get("contact_info", {}),
                    "tracking_info": {
                        "return_label_url": return_data.get("return_label_url", ""),
                        "tracking_number": return_data.get("tracking_number", ""),
                        "carrier": return_data.get("carrier", "")
                    },
                    "message": return_data.get("message", "退货申请已成功提交")
                }
            }
            
            logger.info(f"退货申请提交成功: 订单{order_id}, 产品{product_id}, 申请ID: {formatted_result['data']['return_id']}")
            return formatted_result
        else:
            return result
    
    except Exception as e:
        logger.error(f"提交退货申请异常: {str(e)}", exc_info=True)
        return {
            "success": False,
            "error": f"提交退货申请时发生异常: {str(e)}"
        }


# ==================== 反馈相关工具函数 ====================

async def log_feedback(
    user_id: str,
    feedback_type: str,
    content: str,
    rating: Optional[int] = None,
    order_id: Optional[str] = None,
    product_id: Optional[str] = None
) -> Dict[str, Any]:
    """
    记录用户反馈
    
    记录用户的反馈信息，包括评价、建议、投诉等。
    
    Args:
        user_id: 用户ID
        feedback_type: 反馈类型 (review, complaint, suggestion, compliment)
        content: 反馈内容
        rating: 评分（1-5，可选）
        order_id: 相关订单ID（可选）
        product_id: 相关产品ID（可选）
    
    Returns:
        包含反馈记录结果的字典
    
    Example:
        >>> result = await log_feedback(
        ...     "USER123", "review", "产品质量很好", rating=5, product_id="PROD001"
        ... )
        >>> feedback_id = result["data"]["feedback_id"]
    """
    if not user_id or not isinstance(user_id, str):
        return {
            "success": False,
            "error": "用户ID不能为空且必须是字符串类型"
        }
    
    if not feedback_type or not isinstance(feedback_type, str):
        return {
            "success": False,
            "error": "反馈类型不能为空且必须是字符串类型"
        }
    
    if not content or not isinstance(content, str):
        return {
            "success": False,
            "error": "反馈内容不能为空且必须是字符串类型"
        }
    
    # 支持的反馈类型
    supported_types = ["review", "complaint", "suggestion", "compliment", "question"]
    if feedback_type.lower() not in supported_types:
        return {
            "success": False,
            "error": f"不支持的反馈类型: {feedback_type}。支持的类型: {', '.join(supported_types)}"
        }
    
    # 验证评分
    if rating is not None and (not isinstance(rating, int) or rating < 1 or rating > 5):
        return {
            "success": False,
            "error": "评分必须是1-5之间的整数"
        }
    
    tools = await get_tools_instance()
    
    # 构建反馈数据
    feedback_data = {
        "user_id": user_id,
        "type": feedback_type.lower(),
        "content": content.strip(),
        "submit_time": datetime.now().isoformat(),
        "status": "received"
    }
    
    if rating is not None:
        feedback_data["rating"] = rating
    if order_id:
        feedback_data["order_id"] = order_id
    if product_id:
        feedback_data["product_id"] = product_id
    
    try:
        result = await tools._call_api(
            endpoint="/feedback/submit",
            method="POST",
            data=feedback_data
        )
        
        if result["success"]:
            # 格式化反馈结果
            feedback_result = result["data"]
            formatted_result = {
                "success": True,
                "data": {
                    "feedback_id": feedback_result.get("feedback_id", ""),
                    "user_id": user_id,
                    "type": feedback_type.lower(),
                    "status": "received",
                    "submit_time": feedback_result.get("submit_time", datetime.now().isoformat()),
                    "estimated_response_time": feedback_result.get("estimated_response_time", "24小时内"),
                    "reference_number": feedback_result.get("reference_number", ""),
                    "contact_info": feedback_result.get("contact_info", {}),
                    "message": feedback_result.get("message", "感谢您的反馈，我们会认真处理")
                }
            }
            
            logger.info(f"用户反馈记录成功: 用户{user_id}, 类型{feedback_type}, ID: {formatted_result['data']['feedback_id']}")
            return formatted_result
        else:
            return result
    
    except Exception as e:
        logger.error(f"记录用户反馈异常: {str(e)}", exc_info=True)
        return {
            "success": False,
            "error": f"记录用户反馈时发生异常: {str(e)}"
        }


# ==================== 辅助函数 ====================

def _get_status_description(status: str) -> str:
    """
    获取订单状态的中文描述
    
    Args:
        status: 订单状态代码
    
    Returns:
        状态的中文描述
    """
    status_map = {
        "pending": "待处理",
        "confirmed": "已确认",
        "processing": "处理中",
        "shipped": "已发货",
        "delivered": "已送达",
        "cancelled": "已取消",
        "refunded": "已退款",
        "returned": "已退货",
        "completed": "已完成"
    }
    
    return status_map.get(status.lower(), status)


# ==================== 工具函数注册 ====================

# 导出所有工具函数供AutoGen使用
TOOLS_REGISTRY = {
    "get_product_details": {
        "function": get_product_details,
        "description": "获取产品详细信息，包括名称、价格、库存、规格等",
        "parameters": {
            "product_id": "产品ID（必需）"
        }
    },
    "search_products": {
        "function": search_products,
        "description": "根据关键词和筛选条件搜索产品列表",
        "parameters": {
            "query": "搜索关键词（必需）",
            "category": "产品分类（可选）",
            "min_price": "最低价格（可选）",
            "max_price": "最高价格（可选）",
            "limit": "返回结果数量限制（默认10）",
            "offset": "结果偏移量（默认0）"
        }
    },
    "get_order_status": {
        "function": get_order_status,
        "description": "获取订单的当前状态和详细信息",
        "parameters": {
            "order_id": "订单ID（必需）"
        }
    },
    "cancel_order": {
        "function": cancel_order,
        "description": "取消指定的订单",
        "parameters": {
            "order_id": "订单ID（必需）",
            "reason": "取消原因（可选）"
        }
    },
    "get_active_promotions": {
        "function": get_active_promotions,
        "description": "获取当前正在进行的促销活动列表",
        "parameters": {
            "category": "产品分类（可选）",
            "product_id": "特定产品ID（可选）"
        }
    },
    "get_policy": {
        "function": get_policy,
        "description": "获取公司政策信息，如退货政策、隐私政策等",
        "parameters": {
            "policy_type": "政策类型（必需）：return, privacy, shipping, warranty, terms, refund, exchange, payment"
        }
    },
    "check_return_eligibility": {
        "function": check_return_eligibility,
        "description": "检查指定订单中的产品是否符合退货条件",
        "parameters": {
            "order_id": "订单ID（必需）",
            "product_id": "产品ID（必需）"
        }
    },
    "submit_return_request": {
        "function": submit_return_request,
        "description": "为指定的订单和产品提交退货申请",
        "parameters": {
            "order_id": "订单ID（必需）",
            "product_id": "产品ID（必需）",
            "reason": "退货原因（必需）",
            "description": "详细描述（可选）",
            "images": "相关图片URL列表（可选）"
        }
    },
    "log_feedback": {
        "function": log_feedback,
        "description": "记录用户的反馈信息，包括评价、建议、投诉等",
        "parameters": {
            "user_id": "用户ID（必需）",
            "feedback_type": "反馈类型（必需）：review, complaint, suggestion, compliment, question",
            "content": "反馈内容（必需）",
            "rating": "评分1-5（可选）",
            "order_id": "相关订单ID（可选）",
            "product_id": "相关产品ID（可选）"
        }
    }
}


# ==================== 使用示例 ====================

if __name__ == "__main__":
    import asyncio
    
    async def test_tools():
        """测试工具函数"""
        
        # 测试产品搜索
        print("=== 测试产品搜索 ===")
        result = await search_products("手机", category="电子产品", limit=5)
        print(json.dumps(result, ensure_ascii=False, indent=2))
        
        # 测试获取产品详情
        print("\n=== 测试获取产品详情 ===")
        result = await get_product_details("PROD001")
        print(json.dumps(result, ensure_ascii=False, indent=2))
        
        # 测试获取订单状态
        print("\n=== 测试获取订单状态 ===")
        result = await get_order_status("ORD123456")
        print(json.dumps(result, ensure_ascii=False, indent=2))
        
        # 测试获取促销活动
        print("\n=== 测试获取促销活动 ===")
        result = await get_active_promotions()
        print(json.dumps(result, ensure_ascii=False, indent=2))
        
        # 测试获取政策
        print("\n=== 测试获取退货政策 ===")
        result = await get_policy("return")
        print(json.dumps(result, ensure_ascii=False, indent=2))
        
        # 关闭工具实例
        if _tools_instance:
            await _tools_instance._close_session()
    
    # 运行测试
    asyncio.run(test_tools())
```

### 2. 工具函数配置

```python
# 文件路径: c_app/config/tools_config.py
import os
from typing import Dict, Any

class ToolsConfig:
    """工具函数配置类"""
    
    # API配置
    API_BASE_URL = os.getenv("TOOLS_API_BASE_URL", "http://localhost:8080/api")
    API_TIMEOUT = int(os.getenv("TOOLS_API_TIMEOUT", "30"))
    MAX_RETRIES = int(os.getenv("TOOLS_MAX_RETRIES", "3"))
    RETRY_DELAY = float(os.getenv("TOOLS_RETRY_DELAY", "1.0"))
    
    # 缓存配置
    ENABLE_CACHE = os.getenv("TOOLS_ENABLE_CACHE", "true").lower() == "true"
    CACHE_TTL = int(os.getenv("TOOLS_CACHE_TTL", "300"))  # 5分钟
    
    # 日志配置
    LOG_LEVEL = os.getenv("TOOLS_LOG_LEVEL", "INFO")
    LOG_FILE = os.getenv("TOOLS_LOG_FILE", "tools.log")
    
    # 业务配置
    DEFAULT_SEARCH_LIMIT = int(os.getenv("TOOLS_DEFAULT_SEARCH_LIMIT", "10"))
    MAX_SEARCH_LIMIT = int(os.getenv("TOOLS_MAX_SEARCH_LIMIT", "100"))
    
    @classmethod
    def get_api_config(cls) -> Dict[str, Any]:
        """获取API配置"""
        return {
            "base_url": cls.API_BASE_URL,
            "timeout": cls.API_TIMEOUT,
            "max_retries": cls.MAX_RETRIES,
            "retry_delay": cls.RETRY_DELAY
        }
    
    @classmethod
    def get_cache_config(cls) -> Dict[str, Any]:
        """获取缓存配置"""
        return {
            "enabled": cls.ENABLE_CACHE,
            "ttl": cls.CACHE_TTL
        }
```

### 3. 工具函数集成到AutoGen

```python
# 文件路径: c_app/services/autogen_integration.py
import asyncio
from typing import List, Dict, Any, Callable
from autogen_agentchat.agents import AssistantAgent
from autogen_agentchat.teams import RoundRobinGroupChat
from autogen_agentchat.ui import Console

from .agent_tools import TOOLS_REGISTRY

class CustomerServiceAgent:
    """
    集成工具函数的客服AI智能体
    """
    
    def __init__(self, llm_client):
        self.llm_client = llm_client
        self.tools = self._prepare_tools()
        self.agent = self._create_agent()
    
    def _prepare_tools(self) -> List[Dict[str, Any]]:
        """准备工具函数列表"""
        tools = []
        
        for tool_name, tool_info in TOOLS_REGISTRY.items():
            tool_def = {
                "type": "function",
                "function": {
                    "name": tool_name,
                    "description": tool_info["description"],
                    "parameters": {
                        "type": "object",
                        "properties": {},
                        "required": []
                    }
                }
            }
            
            # 添加参数定义
            for param_name, param_desc in tool_info["parameters"].items():
                tool_def["function"]["parameters"]["properties"][param_name] = {
                    "type": "string",
                    "description": param_desc
                }
                
                # 标记必需参数
                if "（必需）" in param_desc:
                    tool_def["function"]["parameters"]["required"].append(param_name)
            
            tools.append(tool_def)
        
        return tools
    
    def _create_agent(self) -> AssistantAgent:
        """创建客服智能体"""
        
        system_message = """
        你是一个专业的智能客服助手，具备以下能力：
        
        1. **产品咨询**：帮助客户查询产品信息、搜索产品、了解产品详情
        2. **订单管理**：查询订单状态、协助取消订单、处理订单相关问题
        3. **促销活动**：介绍当前的促销活动和优惠信息
        4. **政策查询**：提供退货、隐私、配送等各类政策信息
        5. **退货服务**：检查退货资格、协助提交退货申请
        6. **反馈收集**：记录客户的评价、建议和投诉
        
        **服务原则**：
        - 始终保持友好、专业的态度
        - 准确理解客户需求，提供精确的信息
        - 主动使用工具函数获取实时数据
        - 遇到无法解决的问题时，及时转接人工客服
        - 保护客户隐私，不泄露敏感信息
        
        **工具使用指南**：
        - 根据客户问题选择合适的工具函数
        - 优先使用工具获取准确信息，而不是猜测
        - 对工具返回的结果进行友好的解释和说明
        - 如果工具调用失败，向客户说明情况并提供替代方案
        """
        
        return AssistantAgent(
            name="CustomerServiceAgent",
            model_client=self.llm_client,
            tools=self.tools,
            system_message=system_message
        )
    
    async def handle_message(self, message: str, user_id: str = "") -> str:
        """处理客户消息"""
        try:
            # 创建团队聊天
            team = RoundRobinGroupChat([self.agent])
            
            # 处理消息
            result = await team.run(
                task=f"用户消息: {message}\n用户ID: {user_id}",
                termination_condition=lambda messages: len(messages) >= 2
            )
            
            # 返回最后一条消息
            if result.messages:
                return result.messages[-1].content
            else:
                return "抱歉，我暂时无法处理您的请求，请稍后再试。"
        
        except Exception as e:
            logger.error(f"处理消息异常: {str(e)}", exc_info=True)
            return "抱歉，服务暂时不可用，请联系人工客服。"
```

## 部署配置

### 1. 依赖管理

```txt
# 文件路径: requirements.txt
aiohttp>=3.8.0
autogen-agentchat>=0.5.6
fastapi>=0.104.0
uvicorn>=0.24.0
pydantic>=2.0.0
python-multipart>=0.0.6
python-dotenv>=1.0.0
sqlalchemy>=2.0.0
alembic>=1.12.0
redis>=5.0.0
celery>=5.3.0
pytest>=7.4.0
pytest-asyncio>=0.21.0
```

### 2. 环境变量配置

```env
# 文件路径: .env

# 工具函数API配置
TOOLS_API_BASE_URL=http://localhost:8080/api
TOOLS_API_TIMEOUT=30
TOOLS_MAX_RETRIES=3
TOOLS_RETRY_DELAY=1.0

# 缓存配置
TOOLS_ENABLE_CACHE=true
TOOLS_CACHE_TTL=300

# 日志配置
TOOLS_LOG_LEVEL=INFO
TOOLS_LOG_FILE=logs/tools.log

# 业务配置
TOOLS_DEFAULT_SEARCH_LIMIT=10
TOOLS_MAX_SEARCH_LIMIT=100

# LLM配置
LLM_MODEL=deepseek-chat
LLM_API_KEY=your_api_key_here
LLM_BASE_URL=https://api.deepseek.com

# 数据库配置
DATABASE_URL=sqlite:///./customer_service.db
REDIS_URL=redis://localhost:6379/0
```

### 3. 启动脚本

```python
# 文件路径: main.py
import asyncio
import logging
from contextlib import asynccontextmanager

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles

from c_app.api.v1 import api_router
from c_app.services.agent_tools import get_tools_instance
from c_app.config.tools_config import ToolsConfig

# 配置日志
logging.basicConfig(
    level=getattr(logging, ToolsConfig.LOG_LEVEL),
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(ToolsConfig.LOG_FILE),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger(__name__)

@asynccontextmanager
async def lifespan(app: FastAPI):
    """应用生命周期管理"""
    # 启动时初始化工具实例
    logger.info("初始化工具函数服务...")
    tools_instance = await get_tools_instance()
    logger.info("工具函数服务初始化完成")
    
    yield
    
    # 关闭时清理资源
    logger.info("清理工具函数服务资源...")
    if tools_instance:
        await tools_instance._close_session()
    logger.info("资源清理完成")

# 创建FastAPI应用
app = FastAPI(
    title="智能客服系统",
    description="基于AutoGen的智能客服系统，集成完整的业务工具函数",
    version="1.0.0",
    lifespan=lifespan
)

# CORS配置
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# 注册API路由
app.include_router(api_router, prefix="/api/v1")

# 静态文件服务
app.mount("/static", StaticFiles(directory="static"), name="static")

# 健康检查
@app.get("/health")
async def health_check():
    """健康检查端点"""
    return {
        "status": "healthy",
        "service": "customer-service-tools",
        "version": "1.0.0"
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=8000,
        reload=True,
        log_level="info"
    )
```

### 4. Docker配置

```dockerfile
# 文件路径: Dockerfile
FROM python:3.9-slim

WORKDIR /app

# 安装系统依赖
RUN apt-get update && apt-get install -y \
    gcc \
    && rm -rf /var/lib/apt/lists/*

# 复制依赖文件
COPY requirements.txt .

# 安装Python依赖
RUN pip install --no-cache-dir -r requirements.txt

# 复制应用代码
COPY . .

# 创建日志目录
RUN mkdir -p logs

# 暴露端口
EXPOSE 8000

# 启动命令
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

```yaml
# 文件路径: docker-compose.yml
version: '3.8'

services:
  customer-service:
    build: .
    ports:
      - "8000:8000"
    environment:
      - TOOLS_API_BASE_URL=http://backend-api:8080/api
      - DATABASE_URL=sqlite:///./data/customer_service.db
      - REDIS_URL=redis://redis:6379/0
    volumes:
      - ./data:/app/data
      - ./logs:/app/logs
    depends_on:
      - redis
      - backend-api
    restart: unless-stopped

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    restart: unless-stopped

  backend-api:
    image: your-backend-api:latest
    ports:
      - "8080:8080"
    environment:
      - DATABASE_URL=postgresql://user:pass@postgres:5432/db
    depends_on:
      - postgres
    restart: unless-stopped

  postgres:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=customer_service
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data
    restart: unless-stopped

volumes:
  redis_data:
  postgres_data:
```

## 核心特性

### 1. 统一API调用接口
- **标准化请求处理**：统一的HTTP客户端配置和错误处理
- **自动重试机制**：支持指数退避的智能重试策略
- **超时控制**：可配置的请求超时时间
- **日志记录**：详细的请求和响应日志记录

### 2. 完整的业务工具集
- **产品管理**：产品查询、搜索、详情获取
- **订单处理**：订单状态查询、取消操作
- **促销活动**：活动查询和筛选
- **政策查询**：各类政策文档获取
- **退货服务**：退货资格检查和申请提交
- **反馈收集**：用户反馈记录和处理

### 3. 异步处理支持
- **高并发处理**：基于asyncio的异步架构
- **资源管理**：自动的HTTP会话管理
- **上下文管理**：支持async with语法

### 4. 错误处理和容错
- **分层错误处理**：区分客户端错误和服务器错误
- **优雅降级**：工具调用失败时的备用方案
- **详细错误信息**：结构化的错误响应

### 5. AutoGen集成
- **工具注册表**：标准化的工具函数注册机制
- **智能体集成**：与AutoGen智能体的无缝集成
- **参数验证**：自动的参数类型和格式验证

### 6. 可配置性
- **环境变量配置**：支持通过环境变量调整所有参数
- **多环境支持**：开发、测试、生产环境配置
- **动态配置**：运行时配置更新支持

### 7. 监控和日志
- **结构化日志**：JSON格式的日志输出
- **性能监控**：API调用时间和成功率统计
- **健康检查**：服务状态监控端点

### 8. 扩展性设计
- **插件架构**：易于添加新的工具函数
- **版本控制**：API版本管理支持
- **缓存支持**：可选的响应缓存机制

## 使用示例

### 1. 基本工具调用

```python
# 产品搜索示例
result = await search_products(
    query="智能手机",
    category="电子产品",
    max_price=3000,
    limit=5
)

if result["success"]:
    products = result["data"]["products"]
    for product in products:
        print(f"产品: {product['name']}, 价格: {product['price']}")
else:
    print(f"搜索失败: {result['error']}")
```

### 2. 订单管理示例

```python
# 查询订单状态
order_result = await get_order_status("ORD123456")
if order_result["success"]:
    order = order_result["data"]
    print(f"订单状态: {order['status_description']}")
    print(f"预计送达: {order['estimated_delivery']}")

# 取消订单
cancel_result = await cancel_order("ORD123456", "客户要求取消")
if cancel_result["success"]:
    print("订单取消成功")
    refund_info = cancel_result["data"]["refund_info"]
    print(f"退款金额: {refund_info['amount']}")
```

### 3. 退货处理示例

```python
# 检查退货资格
eligibility = await check_return_eligibility("ORD123456", "PROD001")
if eligibility["success"] and eligibility["data"]["eligible"]:
    # 提交退货申请
    return_request = await submit_return_request(
        order_id="ORD123456",
        product_id="PROD001",
        reason="产品质量问题",
        description="产品有明显划痕"
    )
    
    if return_request["success"]:
        return_id = return_request["data"]["return_id"]
        print(f"退货申请已提交，申请号: {return_id}")
else:
    print("该产品不符合退货条件")
```

### 4. 在AutoGen中使用

```python
from autogen_agentchat.agents import AssistantAgent
from c_app.services.agent_tools import TOOLS_REGISTRY

# 创建带工具的智能体
agent = AssistantAgent(
    name="CustomerServiceAgent",
    model_client=llm_client,
    tools=[tool_info["function"] for tool_info in TOOLS_REGISTRY.values()],
    system_message="你是一个专业的客服助手，可以使用各种工具帮助客户解决问题。"
)

# 处理客户查询
response = await agent.run("我想查询订单ORD123456的状态")
print(response.content)
```

## 最佳实践

### 1. 错误处理
- 始终检查工具函数的返回结果中的`success`字段
- 为用户提供友好的错误信息
- 记录详细的错误日志用于调试

### 2. 性能优化
- 使用连接池减少HTTP连接开销
- 合理设置超时时间避免长时间等待
- 启用缓存减少重复API调用

### 3. 安全考虑
- 验证所有输入参数防止注入攻击
- 使用HTTPS确保数据传输安全
- 不在日志中记录敏感信息

### 4. 监控和维护
- 定期检查API调用成功率
- 监控响应时间和错误率
- 及时更新依赖包版本

通过这套完整的工具函数系统，智能客服可以提供专业、高效的客户服务，覆盖从产品咨询到售后服务的全流程业务需求。