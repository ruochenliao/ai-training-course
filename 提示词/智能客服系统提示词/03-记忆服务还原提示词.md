# 记忆服务还原提示词

## 服务概述

智能客服记忆服务是一个多层次的记忆管理系统，负责存储、检索和管理用户对话历史、个人知识库和公共知识库，为智能客服提供上下文感知和个性化服务能力。

## 技术栈要求

```json
{
  "language": "Python 3.9+",
  "database": "SQLite",
  "vector_store": "In-Memory/File-based",
  "embedding": "Text Embedding Models",
  "async_framework": "asyncio",
  "serialization": "JSON",
  "similarity": "Cosine Similarity"
}
```

## 核心架构设计

### 1. 记忆服务工厂类

```python
# 文件路径: c_app/services/memory_service.py
import json
import sqlite3
import asyncio
import logging
from typing import List, Dict, Any, Optional, Union
from datetime import datetime, timedelta
from dataclasses import dataclass
from abc import ABC, abstractmethod

from ..schemas.customer import ChatMessage

logger = logging.getLogger(__name__)

@dataclass
class MemoryItem:
    """记忆项数据结构"""
    id: str
    content: str
    metadata: Dict[str, Any]
    embedding: Optional[List[float]] = None
    created_at: datetime = None
    updated_at: datetime = None
    
    def __post_init__(self):
        if self.created_at is None:
            self.created_at = datetime.now()
        if self.updated_at is None:
            self.updated_at = datetime.now()

class BaseMemoryService(ABC):
    """记忆服务基类"""
    
    def __init__(self, db_path: str = "./memory.db"):
        self.db_path = db_path
        self._init_database()
    
    @abstractmethod
    def _init_database(self):
        """初始化数据库表"""
        pass
    
    @abstractmethod
    async def add_memory(self, content: str, metadata: Dict[str, Any] = None) -> str:
        """添加记忆"""
        pass
    
    @abstractmethod
    async def retrieve_memories(self, query: str, limit: int = 5) -> List[MemoryItem]:
        """检索相关记忆"""
        pass
    
    @abstractmethod
    async def update_memory(self, memory_id: str, content: str = None, metadata: Dict[str, Any] = None) -> bool:
        """更新记忆"""
        pass
    
    @abstractmethod
    async def delete_memory(self, memory_id: str) -> bool:
        """删除记忆"""
        pass

class MemoryServiceFactory:
    """记忆服务工厂类"""
    
    def __init__(self, db_path: str = "./customer_service.db"):
        self.db_path = db_path
        self._chat_memory_services: Dict[str, 'ChatMemoryService'] = {}
        self._private_memory_services: Dict[str, 'PrivateMemoryService'] = {}
        self._public_memory_service: Optional['PublicMemoryService'] = None
    
    def get_chat_memory_service(self, user_id: str) -> 'ChatMemoryService':
        """获取聊天记忆服务"""
        if user_id not in self._chat_memory_services:
            self._chat_memory_services[user_id] = ChatMemoryService(
                user_id=user_id,
                db_path=self.db_path
            )
        return self._chat_memory_services[user_id]
    
    def get_private_memory_service(self, user_id: str) -> 'PrivateMemoryService':
        """获取私有记忆服务"""
        if user_id not in self._private_memory_services:
            self._private_memory_services[user_id] = PrivateMemoryService(
                user_id=user_id,
                db_path=self.db_path
            )
        return self._private_memory_services[user_id]
    
    def get_public_memory_service(self) -> 'PublicMemoryService':
        """获取公共记忆服务"""
        if self._public_memory_service is None:
            self._public_memory_service = PublicMemoryService(db_path=self.db_path)
        return self._public_memory_service
```

### 2. 聊天记忆服务

```python
class ChatMemoryService(BaseMemoryService):
    """聊天历史记忆服务"""
    
    def __init__(self, user_id: str, db_path: str = "./customer_service.db"):
        self.user_id = user_id
        super().__init__(db_path)
    
    def _init_database(self):
        """初始化聊天记忆数据库表"""
        with sqlite3.connect(self.db_path) as conn:
            conn.execute("""
                CREATE TABLE IF NOT EXISTS chat_memories (
                    id TEXT PRIMARY KEY,
                    user_id TEXT NOT NULL,
                    session_id TEXT NOT NULL,
                    role TEXT NOT NULL,
                    content TEXT NOT NULL,
                    metadata TEXT DEFAULT '{}',
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """)
            
            conn.execute("""
                CREATE INDEX IF NOT EXISTS idx_chat_user_session 
                ON chat_memories(user_id, session_id, created_at)
            """)
            
            conn.execute("""
                CREATE INDEX IF NOT EXISTS idx_chat_user_time 
                ON chat_memories(user_id, created_at DESC)
            """)
    
    async def add_message(self, session_id: str, message: ChatMessage) -> str:
        """添加聊天消息到记忆"""
        memory_id = f"chat_{self.user_id}_{session_id}_{datetime.now().strftime('%Y%m%d_%H%M%S_%f')}"
        
        # 提取文本内容
        content = self._extract_text_content(message.content)
        
        # 构建元数据
        metadata = {
            "session_id": session_id,
            "role": message.role,
            "timestamp": message.timestamp or datetime.now().isoformat(),
            "content_type": "multimodal" if isinstance(message.content, list) else "text"
        }
        
        with sqlite3.connect(self.db_path) as conn:
            conn.execute(
                """INSERT INTO chat_memories 
                   (id, user_id, session_id, role, content, metadata) 
                   VALUES (?, ?, ?, ?, ?, ?)""",
                (
                    memory_id,
                    self.user_id,
                    session_id,
                    message.role,
                    content,
                    json.dumps(metadata)
                )
            )
        
        return memory_id
    
    async def get_session_history(self, session_id: str, limit: int = 50) -> List[ChatMessage]:
        """获取会话历史"""
        with sqlite3.connect(self.db_path) as conn:
            conn.row_factory = sqlite3.Row
            cursor = conn.execute(
                """SELECT * FROM chat_memories 
                   WHERE user_id = ? AND session_id = ? 
                   ORDER BY created_at ASC 
                   LIMIT ?""",
                (self.user_id, session_id, limit)
            )
            rows = cursor.fetchall()
            
            messages = []
            for row in rows:
                try:
                    metadata = json.loads(row["metadata"])
                    message = ChatMessage(
                        role=row["role"],
                        content=row["content"],
                        timestamp=metadata.get("timestamp")
                    )
                    messages.append(message)
                except (json.JSONDecodeError, KeyError) as e:
                    logger.warning(f"Failed to parse chat memory: {e}")
                    continue
            
            return messages
    
    async def get_recent_context(self, limit: int = 10) -> List[MemoryItem]:
        """获取最近的对话上下文"""
        with sqlite3.connect(self.db_path) as conn:
            conn.row_factory = sqlite3.Row
            cursor = conn.execute(
                """SELECT * FROM chat_memories 
                   WHERE user_id = ? 
                   ORDER BY created_at DESC 
                   LIMIT ?""",
                (self.user_id, limit)
            )
            rows = cursor.fetchall()
            
            memories = []
            for row in rows:
                try:
                    metadata = json.loads(row["metadata"])
                    memory = MemoryItem(
                        id=row["id"],
                        content=row["content"],
                        metadata=metadata,
                        created_at=datetime.fromisoformat(row["created_at"]),
                        updated_at=datetime.fromisoformat(row["updated_at"])
                    )
                    memories.append(memory)
                except (json.JSONDecodeError, ValueError) as e:
                    logger.warning(f"Failed to parse memory item: {e}")
                    continue
            
            return memories
    
    async def search_conversations(self, query: str, limit: int = 5) -> List[MemoryItem]:
        """搜索相关对话"""
        query_lower = query.lower()
        
        with sqlite3.connect(self.db_path) as conn:
            conn.row_factory = sqlite3.Row
            cursor = conn.execute(
                """SELECT * FROM chat_memories 
                   WHERE user_id = ? AND LOWER(content) LIKE ? 
                   ORDER BY created_at DESC 
                   LIMIT ?""",
                (self.user_id, f"%{query_lower}%", limit * 2)  # 获取更多结果用于排序
            )
            rows = cursor.fetchall()
            
            # 简单的相关性评分
            scored_memories = []
            for row in rows:
                content_lower = row["content"].lower()
                score = self._calculate_relevance_score(query_lower, content_lower)
                
                if score > 0:
                    try:
                        metadata = json.loads(row["metadata"])
                        memory = MemoryItem(
                            id=row["id"],
                            content=row["content"],
                            metadata={**metadata, "relevance_score": score},
                            created_at=datetime.fromisoformat(row["created_at"]),
                            updated_at=datetime.fromisoformat(row["updated_at"])
                        )
                        scored_memories.append(memory)
                    except (json.JSONDecodeError, ValueError) as e:
                        logger.warning(f"Failed to parse memory item: {e}")
                        continue
            
            # 按相关性排序并返回前N个
            scored_memories.sort(key=lambda x: x.metadata.get("relevance_score", 0), reverse=True)
            return scored_memories[:limit]
    
    def _extract_text_content(self, content: Union[str, List[Dict[str, Any]]]) -> str:
        """从消息内容中提取文本"""
        if isinstance(content, str):
            return content
        
        elif isinstance(content, list):
            text_parts = []
            for item in content:
                if isinstance(item, dict) and item.get("type") == "text":
                    text_parts.append(item.get("text", ""))
            return " ".join(text_parts)
        
        return str(content)
    
    def _calculate_relevance_score(self, query: str, content: str) -> float:
        """计算相关性评分"""
        query_words = set(query.split())
        content_words = set(content.split())
        
        if not query_words:
            return 0.0
        
        # 计算词汇重叠度
        intersection = query_words.intersection(content_words)
        union = query_words.union(content_words)
        
        jaccard_score = len(intersection) / len(union) if union else 0.0
        
        # 考虑完整匹配
        exact_match_bonus = 0.5 if query in content else 0.0
        
        return jaccard_score + exact_match_bonus
    
    # 实现基类抽象方法
    async def add_memory(self, content: str, metadata: Dict[str, Any] = None) -> str:
        """添加通用记忆（用于兼容基类接口）"""
        session_id = metadata.get("session_id", "default") if metadata else "default"
        message = ChatMessage(
            role="user",
            content=content,
            timestamp=datetime.now().isoformat()
        )
        return await self.add_message(session_id, message)
    
    async def retrieve_memories(self, query: str, limit: int = 5) -> List[MemoryItem]:
        """检索相关记忆"""
        return await self.search_conversations(query, limit)
    
    async def update_memory(self, memory_id: str, content: str = None, metadata: Dict[str, Any] = None) -> bool:
        """更新记忆"""
        updates = []
        params = []
        
        if content is not None:
            updates.append("content = ?")
            params.append(content)
        
        if metadata is not None:
            updates.append("metadata = ?")
            params.append(json.dumps(metadata))
        
        if not updates:
            return False
        
        updates.append("updated_at = CURRENT_TIMESTAMP")
        params.append(memory_id)
        
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.execute(
                f"UPDATE chat_memories SET {', '.join(updates)} WHERE id = ?",
                params
            )
            return cursor.rowcount > 0
    
    async def delete_memory(self, memory_id: str) -> bool:
        """删除记忆"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.execute(
                "DELETE FROM chat_memories WHERE id = ? AND user_id = ?",
                (memory_id, self.user_id)
            )
            return cursor.rowcount > 0
    
    async def cleanup_old_memories(self, days: int = 30) -> int:
        """清理过期记忆"""
        cutoff_date = datetime.now() - timedelta(days=days)
        
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.execute(
                "DELETE FROM chat_memories WHERE user_id = ? AND created_at < ?",
                (self.user_id, cutoff_date.isoformat())
            )
            return cursor.rowcount
```

### 3. 私有记忆服务

```python
class PrivateMemoryService(BaseMemoryService):
    """用户私有知识库服务"""
    
    def __init__(self, user_id: str, db_path: str = "./customer_service.db"):
        self.user_id = user_id
        super().__init__(db_path)
    
    def _init_database(self):
        """初始化私有记忆数据库表"""
        with sqlite3.connect(self.db_path) as conn:
            conn.execute("""
                CREATE TABLE IF NOT EXISTS private_memories (
                    id TEXT PRIMARY KEY,
                    user_id TEXT NOT NULL,
                    content TEXT NOT NULL,
                    summary TEXT,
                    tags TEXT DEFAULT '[]',
                    metadata TEXT DEFAULT '{}',
                    embedding TEXT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """)
            
            conn.execute("""
                CREATE INDEX IF NOT EXISTS idx_private_user 
                ON private_memories(user_id, created_at DESC)
            """)
            
            conn.execute("""
                CREATE INDEX IF NOT EXISTS idx_private_tags 
                ON private_memories(user_id, tags)
            """)
    
    async def add_memory(self, content: str, metadata: Dict[str, Any] = None) -> str:
        """添加私有记忆"""
        memory_id = f"private_{self.user_id}_{datetime.now().strftime('%Y%m%d_%H%M%S_%f')}"
        
        # 生成摘要
        summary = self._generate_summary(content)
        
        # 提取标签
        tags = metadata.get("tags", []) if metadata else []
        
        # 生成嵌入向量（简化版本，实际应使用专业的嵌入模型）
        embedding = self._generate_embedding(content)
        
        with sqlite3.connect(self.db_path) as conn:
            conn.execute(
                """INSERT INTO private_memories 
                   (id, user_id, content, summary, tags, metadata, embedding) 
                   VALUES (?, ?, ?, ?, ?, ?, ?)""",
                (
                    memory_id,
                    self.user_id,
                    content,
                    summary,
                    json.dumps(tags),
                    json.dumps(metadata or {}),
                    json.dumps(embedding)
                )
            )
        
        return memory_id
    
    async def retrieve_memories(self, query: str, limit: int = 5) -> List[MemoryItem]:
        """检索相关私有记忆"""
        # 生成查询嵌入
        query_embedding = self._generate_embedding(query)
        
        with sqlite3.connect(self.db_path) as conn:
            conn.row_factory = sqlite3.Row
            cursor = conn.execute(
                "SELECT * FROM private_memories WHERE user_id = ?",
                (self.user_id,)
            )
            rows = cursor.fetchall()
            
            # 计算相似度并排序
            scored_memories = []
            for row in rows:
                try:
                    # 文本匹配评分
                    text_score = self._calculate_text_similarity(query, row["content"])
                    
                    # 向量相似度评分
                    stored_embedding = json.loads(row["embedding"]) if row["embedding"] else []
                    vector_score = self._calculate_cosine_similarity(query_embedding, stored_embedding)
                    
                    # 综合评分
                    final_score = 0.6 * text_score + 0.4 * vector_score
                    
                    if final_score > 0.1:  # 相关性阈值
                        metadata = json.loads(row["metadata"])
                        metadata["relevance_score"] = final_score
                        metadata["tags"] = json.loads(row["tags"])
                        
                        memory = MemoryItem(
                            id=row["id"],
                            content=row["content"],
                            metadata=metadata,
                            created_at=datetime.fromisoformat(row["created_at"]),
                            updated_at=datetime.fromisoformat(row["updated_at"])
                        )
                        scored_memories.append(memory)
                        
                except (json.JSONDecodeError, ValueError) as e:
                    logger.warning(f"Failed to process private memory: {e}")
                    continue
            
            # 按相关性排序
            scored_memories.sort(key=lambda x: x.metadata.get("relevance_score", 0), reverse=True)
            return scored_memories[:limit]
    
    async def add_user_preference(self, preference_type: str, preference_value: str, context: str = "") -> str:
        """添加用户偏好"""
        content = f"用户偏好 - {preference_type}: {preference_value}"
        if context:
            content += f" (上下文: {context})"
        
        metadata = {
            "type": "user_preference",
            "preference_type": preference_type,
            "preference_value": preference_value,
            "context": context,
            "tags": ["偏好", preference_type]
        }
        
        return await self.add_memory(content, metadata)
    
    async def add_user_history(self, action: str, details: Dict[str, Any]) -> str:
        """添加用户行为历史"""
        content = f"用户行为 - {action}: {json.dumps(details, ensure_ascii=False)}"
        
        metadata = {
            "type": "user_history",
            "action": action,
            "details": details,
            "tags": ["历史", action]
        }
        
        return await self.add_memory(content, metadata)
    
    async def get_user_preferences(self, preference_type: str = None) -> List[MemoryItem]:
        """获取用户偏好"""
        with sqlite3.connect(self.db_path) as conn:
            conn.row_factory = sqlite3.Row
            
            if preference_type:
                cursor = conn.execute(
                    """SELECT * FROM private_memories 
                       WHERE user_id = ? AND metadata LIKE ? 
                       ORDER BY created_at DESC""",
                    (self.user_id, f'%"preference_type": "{preference_type}"%')
                )
            else:
                cursor = conn.execute(
                    """SELECT * FROM private_memories 
                       WHERE user_id = ? AND metadata LIKE ? 
                       ORDER BY created_at DESC""",
                    (self.user_id, '%"type": "user_preference"%')
                )
            
            rows = cursor.fetchall()
            
            memories = []
            for row in rows:
                try:
                    metadata = json.loads(row["metadata"])
                    memory = MemoryItem(
                        id=row["id"],
                        content=row["content"],
                        metadata=metadata,
                        created_at=datetime.fromisoformat(row["created_at"]),
                        updated_at=datetime.fromisoformat(row["updated_at"])
                    )
                    memories.append(memory)
                except (json.JSONDecodeError, ValueError) as e:
                    logger.warning(f"Failed to parse preference memory: {e}")
                    continue
            
            return memories
    
    def _generate_summary(self, content: str, max_length: int = 100) -> str:
        """生成内容摘要"""
        if len(content) <= max_length:
            return content
        
        # 简单的摘要生成：取前N个字符
        summary = content[:max_length].strip()
        if summary != content:
            summary += "..."
        
        return summary
    
    def _generate_embedding(self, text: str) -> List[float]:
        """生成文本嵌入向量（简化版本）"""
        # 这里使用简化的词频向量作为示例
        # 实际应用中应该使用专业的嵌入模型如 sentence-transformers
        
        words = text.lower().split()
        word_freq = {}
        
        for word in words:
            word_freq[word] = word_freq.get(word, 0) + 1
        
        # 创建固定长度的向量（100维）
        vocab_size = 100
        embedding = [0.0] * vocab_size
        
        for i, word in enumerate(sorted(word_freq.keys())[:vocab_size]):
            embedding[i] = word_freq[word] / len(words)
        
        return embedding
    
    def _calculate_text_similarity(self, query: str, content: str) -> float:
        """计算文本相似度"""
        query_words = set(query.lower().split())
        content_words = set(content.lower().split())
        
        if not query_words or not content_words:
            return 0.0
        
        intersection = query_words.intersection(content_words)
        union = query_words.union(content_words)
        
        return len(intersection) / len(union) if union else 0.0
    
    def _calculate_cosine_similarity(self, vec1: List[float], vec2: List[float]) -> float:
        """计算余弦相似度"""
        if not vec1 or not vec2 or len(vec1) != len(vec2):
            return 0.0
        
        dot_product = sum(a * b for a, b in zip(vec1, vec2))
        magnitude1 = sum(a * a for a in vec1) ** 0.5
        magnitude2 = sum(b * b for b in vec2) ** 0.5
        
        if magnitude1 == 0 or magnitude2 == 0:
            return 0.0
        
        return dot_product / (magnitude1 * magnitude2)
    
    # 实现基类抽象方法
    async def update_memory(self, memory_id: str, content: str = None, metadata: Dict[str, Any] = None) -> bool:
        """更新私有记忆"""
        updates = []
        params = []
        
        if content is not None:
            updates.append("content = ?")
            params.append(content)
            
            # 重新生成摘要和嵌入
            updates.append("summary = ?")
            params.append(self._generate_summary(content))
            
            updates.append("embedding = ?")
            params.append(json.dumps(self._generate_embedding(content)))
        
        if metadata is not None:
            updates.append("metadata = ?")
            params.append(json.dumps(metadata))
            
            if "tags" in metadata:
                updates.append("tags = ?")
                params.append(json.dumps(metadata["tags"]))
        
        if not updates:
            return False
        
        updates.append("updated_at = CURRENT_TIMESTAMP")
        params.append(memory_id)
        params.append(self.user_id)
        
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.execute(
                f"UPDATE private_memories SET {', '.join(updates)} WHERE id = ? AND user_id = ?",
                params
            )
            return cursor.rowcount > 0
    
    async def delete_memory(self, memory_id: str) -> bool:
        """删除私有记忆"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.execute(
                "DELETE FROM private_memories WHERE id = ? AND user_id = ?",
                (memory_id, self.user_id)
            )
            return cursor.rowcount > 0
```

### 4. 公共记忆服务

```python
class PublicMemoryService(BaseMemoryService):
    """公共知识库服务"""
    
    def _init_database(self):
        """初始化公共记忆数据库表"""
        with sqlite3.connect(self.db_path) as conn:
            conn.execute("""
                CREATE TABLE IF NOT EXISTS public_memories (
                    id TEXT PRIMARY KEY,
                    category TEXT NOT NULL,
                    title TEXT NOT NULL,
                    content TEXT NOT NULL,
                    summary TEXT,
                    tags TEXT DEFAULT '[]',
                    metadata TEXT DEFAULT '{}',
                    embedding TEXT,
                    priority INTEGER DEFAULT 0,
                    is_active BOOLEAN DEFAULT 1,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """)
            
            conn.execute("""
                CREATE INDEX IF NOT EXISTS idx_public_category 
                ON public_memories(category, is_active, priority DESC)
            """)
            
            conn.execute("""
                CREATE INDEX IF NOT EXISTS idx_public_tags 
                ON public_memories(tags, is_active)
            """)
            
            # 初始化默认知识库内容
            self._init_default_knowledge()
    
    def _init_default_knowledge(self):
        """初始化默认知识库内容"""
        default_knowledge = [
            {
                "category": "policy",
                "title": "退货政策",
                "content": "我们提供30天无理由退货服务。商品需保持原包装完整，未使用状态。退货运费由买家承担，质量问题除外。",
                "tags": ["退货", "政策", "售后"]
            },
            {
                "category": "policy",
                "title": "换货政策",
                "content": "商品质量问题可在7天内申请换货。换货商品需保持原包装，我们承担换货运费。",
                "tags": ["换货", "政策", "售后"]
            },
            {
                "category": "shipping",
                "title": "配送时间",
                "content": "一般商品1-3个工作日发货，偏远地区可能需要5-7个工作日。急需商品可选择加急配送。",
                "tags": ["配送", "时间", "物流"]
            },
            {
                "category": "payment",
                "title": "支付方式",
                "content": "支持微信支付、支付宝、银行卡支付。企业客户可申请月结账期。",
                "tags": ["支付", "方式", "结算"]
            },
            {
                "category": "service",
                "title": "客服时间",
                "content": "客服工作时间：周一至周日 9:00-21:00。节假日可能有调整，具体以公告为准。",
                "tags": ["客服", "时间", "服务"]
            }
        ]
        
        with sqlite3.connect(self.db_path) as conn:
            for item in default_knowledge:
                # 检查是否已存在
                cursor = conn.execute(
                    "SELECT id FROM public_memories WHERE title = ?",
                    (item["title"],)
                )
                if cursor.fetchone():
                    continue
                
                # 添加新的知识项
                memory_id = f"public_{item['category']}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
                embedding = self._generate_embedding(item["content"])
                
                conn.execute(
                    """INSERT INTO public_memories 
                       (id, category, title, content, summary, tags, embedding, priority) 
                       VALUES (?, ?, ?, ?, ?, ?, ?, ?)""",
                    (
                        memory_id,
                        item["category"],
                        item["title"],
                        item["content"],
                        item["content"][:100] + "..." if len(item["content"]) > 100 else item["content"],
                        json.dumps(item["tags"]),
                        json.dumps(embedding),
                        1  # 默认优先级
                    )
                )
    
    async def add_memory(self, content: str, metadata: Dict[str, Any] = None) -> str:
        """添加公共知识"""
        metadata = metadata or {}
        memory_id = f"public_{metadata.get('category', 'general')}_{datetime.now().strftime('%Y%m%d_%H%M%S_%f')}"
        
        category = metadata.get("category", "general")
        title = metadata.get("title", content[:50] + "..." if len(content) > 50 else content)
        tags = metadata.get("tags", [])
        priority = metadata.get("priority", 0)
        
        # 生成摘要和嵌入
        summary = self._generate_summary(content)
        embedding = self._generate_embedding(content)
        
        with sqlite3.connect(self.db_path) as conn:
            conn.execute(
                """INSERT INTO public_memories 
                   (id, category, title, content, summary, tags, metadata, embedding, priority) 
                   VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)""",
                (
                    memory_id,
                    category,
                    title,
                    content,
                    summary,
                    json.dumps(tags),
                    json.dumps(metadata),
                    json.dumps(embedding),
                    priority
                )
            )
        
        return memory_id
    
    async def retrieve_memories(self, query: str, limit: int = 5) -> List[MemoryItem]:
        """检索相关公共知识"""
        query_embedding = self._generate_embedding(query)
        
        with sqlite3.connect(self.db_path) as conn:
            conn.row_factory = sqlite3.Row
            cursor = conn.execute(
                "SELECT * FROM public_memories WHERE is_active = 1"
            )
            rows = cursor.fetchall()
            
            scored_memories = []
            for row in rows:
                try:
                    # 计算相关性评分
                    text_score = self._calculate_text_similarity(query, row["content"])
                    title_score = self._calculate_text_similarity(query, row["title"])
                    
                    stored_embedding = json.loads(row["embedding"]) if row["embedding"] else []
                    vector_score = self._calculate_cosine_similarity(query_embedding, stored_embedding)
                    
                    # 综合评分（标题权重更高）
                    final_score = 0.4 * text_score + 0.4 * title_score + 0.2 * vector_score
                    
                    # 优先级加权
                    priority_bonus = row["priority"] * 0.1
                    final_score += priority_bonus
                    
                    if final_score > 0.1:
                        metadata = json.loads(row["metadata"])
                        metadata.update({
                            "relevance_score": final_score,
                            "category": row["category"],
                            "title": row["title"],
                            "tags": json.loads(row["tags"]),
                            "priority": row["priority"]
                        })
                        
                        memory = MemoryItem(
                            id=row["id"],
                            content=row["content"],
                            metadata=metadata,
                            created_at=datetime.fromisoformat(row["created_at"]),
                            updated_at=datetime.fromisoformat(row["updated_at"])
                        )
                        scored_memories.append(memory)
                        
                except (json.JSONDecodeError, ValueError) as e:
                    logger.warning(f"Failed to process public memory: {e}")
                    continue
            
            # 按相关性排序
            scored_memories.sort(key=lambda x: x.metadata.get("relevance_score", 0), reverse=True)
            return scored_memories[:limit]
    
    async def get_by_category(self, category: str, limit: int = 10) -> List[MemoryItem]:
        """按分类获取知识"""
        with sqlite3.connect(self.db_path) as conn:
            conn.row_factory = sqlite3.Row
            cursor = conn.execute(
                """SELECT * FROM public_memories 
                   WHERE category = ? AND is_active = 1 
                   ORDER BY priority DESC, created_at DESC 
                   LIMIT ?""",
                (category, limit)
            )
            rows = cursor.fetchall()
            
            memories = []
            for row in rows:
                try:
                    metadata = json.loads(row["metadata"])
                    metadata.update({
                        "category": row["category"],
                        "title": row["title"],
                        "tags": json.loads(row["tags"]),
                        "priority": row["priority"]
                    })
                    
                    memory = MemoryItem(
                        id=row["id"],
                        content=row["content"],
                        metadata=metadata,
                        created_at=datetime.fromisoformat(row["created_at"]),
                        updated_at=datetime.fromisoformat(row["updated_at"])
                    )
                    memories.append(memory)
                except (json.JSONDecodeError, ValueError) as e:
                    logger.warning(f"Failed to parse public memory: {e}")
                    continue
            
            return memories
    
    async def update_memory(self, memory_id: str, content: str = None, metadata: Dict[str, Any] = None) -> bool:
        """更新公共知识"""
        updates = []
        params = []
        
        if content is not None:
            updates.extend(["content = ?", "summary = ?", "embedding = ?"])
            params.extend([
                content,
                self._generate_summary(content),
                json.dumps(self._generate_embedding(content))
            ])
        
        if metadata is not None:
            if "title" in metadata:
                updates.append("title = ?")
                params.append(metadata["title"])
            
            if "category" in metadata:
                updates.append("category = ?")
                params.append(metadata["category"])
            
            if "tags" in metadata:
                updates.append("tags = ?")
                params.append(json.dumps(metadata["tags"]))
            
            if "priority" in metadata:
                updates.append("priority = ?")
                params.append(metadata["priority"])
            
            if "is_active" in metadata:
                updates.append("is_active = ?")
                params.append(metadata["is_active"])
            
            updates.append("metadata = ?")
            params.append(json.dumps(metadata))
        
        if not updates:
            return False
        
        updates.append("updated_at = CURRENT_TIMESTAMP")
        params.append(memory_id)
        
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.execute(
                f"UPDATE public_memories SET {', '.join(updates)} WHERE id = ?",
                params
            )
            return cursor.rowcount > 0
    
    async def delete_memory(self, memory_id: str) -> bool:
        """删除公共知识（软删除）"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.execute(
                "UPDATE public_memories SET is_active = 0, updated_at = CURRENT_TIMESTAMP WHERE id = ?",
                (memory_id,)
            )
            return cursor.rowcount > 0
    
    def _generate_summary(self, content: str, max_length: int = 150) -> str:
        """生成内容摘要"""
        if len(content) <= max_length:
            return content
        
        # 尝试在句号处截断
        truncated = content[:max_length]
        last_period = truncated.rfind('。')
        
        if last_period > max_length * 0.7:  # 如果句号位置合理
            return truncated[:last_period + 1]
        else:
            return truncated.strip() + "..."
    
    def _generate_embedding(self, text: str) -> List[float]:
        """生成文本嵌入向量"""
        # 与私有记忆服务使用相同的嵌入方法
        words = text.lower().split()
        word_freq = {}
        
        for word in words:
            word_freq[word] = word_freq.get(word, 0) + 1
        
        vocab_size = 100
        embedding = [0.0] * vocab_size
        
        for i, word in enumerate(sorted(word_freq.keys())[:vocab_size]):
            embedding[i] = word_freq[word] / len(words)
        
        return embedding
    
    def _calculate_text_similarity(self, query: str, content: str) -> float:
        """计算文本相似度"""
        query_words = set(query.lower().split())
        content_words = set(content.lower().split())
        
        if not query_words or not content_words:
            return 0.0
        
        intersection = query_words.intersection(content_words)
        union = query_words.union(content_words)
        
        jaccard_score = len(intersection) / len(union) if union else 0.0
        
        # 考虑完整匹配
        exact_match_bonus = 0.3 if query.lower() in content.lower() else 0.0
        
        return min(jaccard_score + exact_match_bonus, 1.0)
    
    def _calculate_cosine_similarity(self, vec1: List[float], vec2: List[float]) -> float:
        """计算余弦相似度"""
        if not vec1 or not vec2 or len(vec1) != len(vec2):
            return 0.0
        
        dot_product = sum(a * b for a, b in zip(vec1, vec2))
        magnitude1 = sum(a * a for a in vec1) ** 0.5
        magnitude2 = sum(b * b for b in vec2) ** 0.5
        
        if magnitude1 == 0 or magnitude2 == 0:
            return 0.0
        
        return dot_product / (magnitude1 * magnitude2)
```

### 5. 记忆服务使用示例

```python
# 文件路径: c_app/services/memory_service_example.py
import asyncio
from .memory_service import MemoryServiceFactory
from ..schemas.customer import ChatMessage

async def memory_service_example():
    """记忆服务使用示例"""
    
    # 创建记忆服务工厂
    memory_factory = MemoryServiceFactory()
    
    # 用户ID
    user_id = "user_123"
    session_id = "session_456"
    
    # 获取各种记忆服务
    chat_memory = memory_factory.get_chat_memory_service(user_id)
    private_memory = memory_factory.get_private_memory_service(user_id)
    public_memory = memory_factory.get_public_memory_service()
    
    # 1. 聊天记忆示例
    print("=== 聊天记忆示例 ===")
    
    # 添加用户消息
    user_message = ChatMessage(
        role="user",
        content="我想了解一下退货政策",
        timestamp="2024-01-01T10:00:00"
    )
    await chat_memory.add_message(session_id, user_message)
    
    # 添加助手回复
    assistant_message = ChatMessage(
        role="assistant",
        content="我们提供30天无理由退货服务，商品需保持原包装完整...",
        timestamp="2024-01-01T10:00:30"
    )
    await chat_memory.add_message(session_id, assistant_message)
    
    # 检索相关对话
    related_chats = await chat_memory.search_conversations("退货", limit=3)
    print(f"找到 {len(related_chats)} 条相关对话")
    
    # 2. 私有记忆示例
    print("\n=== 私有记忆示例 ===")
    
    # 添加用户偏好
    await private_memory.add_user_preference(
        "product_category", 
        "电子产品", 
        "用户经常购买手机和电脑"
    )
    
    # 添加用户历史
    await private_memory.add_user_history(
        "purchase",
        {
            "product_id": "phone_001",
            "product_name": "iPhone 15",
            "price": 6999,
            "date": "2024-01-01"
        }
    )
    
    # 检索用户偏好
    preferences = await private_memory.get_user_preferences("product_category")
    print(f"找到 {len(preferences)} 条用户偏好")
    
    # 3. 公共记忆示例
    print("\n=== 公共记忆示例 ===")
    
    # 添加新的公共知识
    await public_memory.add_memory(
        "我们新增了7天价保服务，购买后7天内如发现同款商品降价，可申请价格保护。",
        {
            "category": "policy",
            "title": "价格保护政策",
            "tags": ["价保", "政策", "优惠"],
            "priority": 2
        }
    )
    
    # 检索相关公共知识
    public_knowledge = await public_memory.retrieve_memories("退货政策", limit=3)
    print(f"找到 {len(public_knowledge)} 条相关公共知识")
    
    # 按分类获取知识
    policy_knowledge = await public_memory.get_by_category("policy", limit=5)
    print(f"找到 {len(policy_knowledge)} 条政策相关知识")
    
    # 4. 综合检索示例
    print("\n=== 综合检索示例 ===")
    
    query = "我想退货"
    
    # 检索各类记忆
    chat_results = await chat_memory.retrieve_memories(query, limit=2)
    private_results = await private_memory.retrieve_memories(query, limit=2)
    public_results = await public_memory.retrieve_memories(query, limit=3)
    
    print(f"聊天记忆: {len(chat_results)} 条")
    print(f"私有记忆: {len(private_results)} 条")
    print(f"公共记忆: {len(public_results)} 条")
    
    # 组合所有结果
    all_results = chat_results + private_results + public_results
    
    # 按相关性排序
    all_results.sort(
        key=lambda x: x.metadata.get("relevance_score", 0), 
        reverse=True
    )
    
    print(f"\n总共找到 {len(all_results)} 条相关记忆")
    for i, result in enumerate(all_results[:5]):
        score = result.metadata.get("relevance_score", 0)
        print(f"{i+1}. [{score:.3f}] {result.content[:50]}...")

if __name__ == "__main__":
    asyncio.run(memory_service_example())
```

## 部署配置

### 数据库初始化脚本

```python
# 文件路径: c_app/utils/init_memory_db.py
import sqlite3
import json
from datetime import datetime

def init_memory_database(db_path: str = "./customer_service.db"):
    """初始化记忆数据库"""
    
    with sqlite3.connect(db_path) as conn:
        # 创建所有表
        conn.executescript("""
            -- 聊天记忆表
            CREATE TABLE IF NOT EXISTS chat_memories (
                id TEXT PRIMARY KEY,
                user_id TEXT NOT NULL,
                session_id TEXT NOT NULL,
                role TEXT NOT NULL,
                content TEXT NOT NULL,
                metadata TEXT DEFAULT '{}',
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
            
            -- 私有记忆表
            CREATE TABLE IF NOT EXISTS private_memories (
                id TEXT PRIMARY KEY,
                user_id TEXT NOT NULL,
                content TEXT NOT NULL,
                summary TEXT,
                tags TEXT DEFAULT '[]',
                metadata TEXT DEFAULT '{}',
                embedding TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
            
            -- 公共记忆表
            CREATE TABLE IF NOT EXISTS public_memories (
                id TEXT PRIMARY KEY,
                category TEXT NOT NULL,
                title TEXT NOT NULL,
                content TEXT NOT NULL,
                summary TEXT,
                tags TEXT DEFAULT '[]',
                metadata TEXT DEFAULT '{}',
                embedding TEXT,
                priority INTEGER DEFAULT 0,
                is_active BOOLEAN DEFAULT 1,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
            
            -- 创建索引
            CREATE INDEX IF NOT EXISTS idx_chat_user_session ON chat_memories(user_id, session_id, created_at);
            CREATE INDEX IF NOT EXISTS idx_chat_user_time ON chat_memories(user_id, created_at DESC);
            CREATE INDEX IF NOT EXISTS idx_private_user ON private_memories(user_id, created_at DESC);
            CREATE INDEX IF NOT EXISTS idx_private_tags ON private_memories(user_id, tags);
            CREATE INDEX IF NOT EXISTS idx_public_category ON public_memories(category, is_active, priority DESC);
            CREATE INDEX IF NOT EXISTS idx_public_tags ON public_memories(tags, is_active);
        """)
        
        print(f"记忆数据库初始化完成: {db_path}")

if __name__ == "__main__":
    init_memory_database()
```

### 配置文件

```python
# 文件路径: c_app/config/memory_config.py
import os
from typing import Dict, Any

class MemoryConfig:
    """记忆服务配置"""
    
    # 数据库配置
    DATABASE_PATH: str = os.getenv("MEMORY_DB_PATH", "./customer_service.db")
    
    # 记忆限制
    MAX_CHAT_MEMORIES_PER_USER: int = int(os.getenv("MAX_CHAT_MEMORIES_PER_USER", "1000"))
    MAX_PRIVATE_MEMORIES_PER_USER: int = int(os.getenv("MAX_PRIVATE_MEMORIES_PER_USER", "500"))
    MAX_PUBLIC_MEMORIES: int = int(os.getenv("MAX_PUBLIC_MEMORIES", "10000"))
    
    # 检索配置
    DEFAULT_RETRIEVAL_LIMIT: int = int(os.getenv("DEFAULT_RETRIEVAL_LIMIT", "5"))
    RELEVANCE_THRESHOLD: float = float(os.getenv("RELEVANCE_THRESHOLD", "0.1"))
    
    # 嵌入向量配置
    EMBEDDING_DIMENSION: int = int(os.getenv("EMBEDDING_DIMENSION", "100"))
    
    # 清理配置
    CHAT_MEMORY_RETENTION_DAYS: int = int(os.getenv("CHAT_MEMORY_RETENTION_DAYS", "30"))
    PRIVATE_MEMORY_RETENTION_DAYS: int = int(os.getenv("PRIVATE_MEMORY_RETENTION_DAYS", "365"))
    
    @classmethod
    def get_config(cls) -> Dict[str, Any]:
        """获取配置字典"""
        return {
            "database_path": cls.DATABASE_PATH,
            "max_chat_memories_per_user": cls.MAX_CHAT_MEMORIES_PER_USER,
            "max_private_memories_per_user": cls.MAX_PRIVATE_MEMORIES_PER_USER,
            "max_public_memories": cls.MAX_PUBLIC_MEMORIES,
            "default_retrieval_limit": cls.DEFAULT_RETRIEVAL_LIMIT,
            "relevance_threshold": cls.RELEVANCE_THRESHOLD,
            "embedding_dimension": cls.EMBEDDING_DIMENSION,
            "chat_memory_retention_days": cls.CHAT_MEMORY_RETENTION_DAYS,
            "private_memory_retention_days": cls.PRIVATE_MEMORY_RETENTION_DAYS
        }

memory_config = MemoryConfig()
```

## 关键特性说明

1. **多层次记忆**: 聊天历史、私有知识库、公共知识库
2. **智能检索**: 文本匹配 + 向量相似度计算
3. **个性化服务**: 用户偏好和行为历史记录
4. **知识管理**: 分类管理、优先级排序、软删除
5. **性能优化**: 数据库索引、相关性阈值过滤
6. **扩展性**: 支持自定义嵌入模型和相似度算法
7. **数据持久化**: SQLite 数据库存储
8. **异步处理**: 全异步的记忆操作

---

此提示词包含了完整的记忆服务实现细节，可以直接用于还原智能客服系统的记忆管理功能。