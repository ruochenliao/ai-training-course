# 可视化推荐服务功能还原提示词

## 服务概述

可视化推荐服务负责分析SQL查询结果的数据特征，智能推荐最适合的图表类型和可视化方案，并生成可视化配置参数。该服务帮助用户快速创建有效的数据可视化，提升数据分析和展示效果。

## 核心功能

### 1. 数据特征分析
- 分析查询结果的数据类型和分布
- 识别数值型、分类型、时间型数据
- 计算数据的统计特征和相关性
- 检测数据的维度和粒度

### 2. 图表类型推荐
- 基于数据特征智能推荐图表类型
- 支持柱状图、折线图、饼图、散点图等
- 考虑数据量和复杂度选择合适的可视化
- 提供多种备选方案和推荐理由

### 3. 可视化配置生成
- 自动生成图表配置参数
- 包括坐标轴、颜色、标签等设置
- 支持多种可视化库的配置格式
- 提供交互式配置选项

### 4. 可视化最佳实践
- 应用数据可视化设计原则
- 确保图表的可读性和美观性
- 提供颜色搭配和布局建议
- 支持响应式设计和多设备适配

## 技术实现

### 可视化推荐核心类

```python
from typing import Dict, List, Optional, Any, Tuple
import pandas as pd
import numpy as np
from dataclasses import dataclass
from enum import Enum
import json
from datetime import datetime
import logging

logger = logging.getLogger(__name__)

class ChartType(Enum):
    BAR = "bar"
    LINE = "line"
    PIE = "pie"
    SCATTER = "scatter"
    AREA = "area"
    HISTOGRAM = "histogram"
    BOX = "box"
    HEATMAP = "heatmap"
    TREEMAP = "treemap"
    GAUGE = "gauge"
    TABLE = "table"
    CARD = "card"

class DataType(Enum):
    NUMERIC = "numeric"
    CATEGORICAL = "categorical"
    TEMPORAL = "temporal"
    BOOLEAN = "boolean"
    TEXT = "text"

@dataclass
class ColumnInfo:
    """列信息"""
    name: str
    data_type: DataType
    unique_count: int
    null_count: int
    sample_values: List[Any]
    statistics: Dict[str, Any] = None

@dataclass
class DataCharacteristics:
    """数据特征"""
    row_count: int
    column_count: int
    columns: List[ColumnInfo]
    numeric_columns: List[str]
    categorical_columns: List[str]
    temporal_columns: List[str]
    data_complexity: str
    relationships: List[Dict[str, Any]]

@dataclass
class ChartRecommendation:
    """图表推荐"""
    chart_type: ChartType
    confidence: float
    reason: str
    config: Dict[str, Any]
    x_axis: Optional[str] = None
    y_axis: Optional[str] = None
    color_by: Optional[str] = None
    size_by: Optional[str] = None
    alternatives: List['ChartRecommendation'] = None

class VisualizationRecommenderAgent:
    """可视化推荐智能体"""
    
    def __init__(self, llm_client=None):
        self.llm_client = llm_client
        self.chart_rules = self._load_chart_rules()
        self.color_palettes = self._load_color_palettes()
        self.chart_templates = self._load_chart_templates()
    
    async def recommend_visualizations(self, 
                                     query_result: pd.DataFrame,
                                     sql_query: str = None,
                                     context: Dict[str, Any] = None) -> Dict[str, Any]:
        """推荐可视化方案"""
        try:
            # 分析数据特征
            data_characteristics = self._analyze_data_characteristics(query_result)
            
            # 生成图表推荐
            recommendations = self._generate_chart_recommendations(data_characteristics)
            
            # 使用LLM增强推荐
            if self.llm_client:
                enhanced_recommendations = await self._enhance_recommendations_with_llm(
                    recommendations, data_characteristics, sql_query, context
                )
            else:
                enhanced_recommendations = recommendations
            
            # 生成可视化配置
            visualization_configs = self._generate_visualization_configs(
                enhanced_recommendations, data_characteristics
            )
            
            # 生成最佳实践建议
            best_practices = self._generate_best_practices(
                enhanced_recommendations, data_characteristics
            )
            
            return {
                'success': True,
                'data_characteristics': data_characteristics.__dict__,
                'recommendations': [rec.__dict__ for rec in enhanced_recommendations],
                'visualization_configs': visualization_configs,
                'best_practices': best_practices,
                'timestamp': datetime.now().isoformat()
            }
            
        except Exception as e:
            logger.error(f"可视化推荐失败: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    def _analyze_data_characteristics(self, df: pd.DataFrame) -> DataCharacteristics:
        """分析数据特征"""
        columns = []
        numeric_columns = []
        categorical_columns = []
        temporal_columns = []
        
        for col in df.columns:
            # 确定数据类型
            data_type = self._determine_data_type(df[col])
            
            # 计算基本统计信息
            unique_count = df[col].nunique()
            null_count = df[col].isnull().sum()
            sample_values = df[col].dropna().head(5).tolist()
            
            # 计算详细统计信息
            statistics = self._calculate_column_statistics(df[col], data_type)
            
            column_info = ColumnInfo(
                name=col,
                data_type=data_type,
                unique_count=unique_count,
                null_count=null_count,
                sample_values=sample_values,
                statistics=statistics
            )
            
            columns.append(column_info)
            
            # 分类到不同类型列表
            if data_type == DataType.NUMERIC:
                numeric_columns.append(col)
            elif data_type == DataType.CATEGORICAL:
                categorical_columns.append(col)
            elif data_type == DataType.TEMPORAL:
                temporal_columns.append(col)
        
        # 分析数据复杂度
        data_complexity = self._assess_data_complexity(df, columns)
        
        # 分析列之间的关系
        relationships = self._analyze_column_relationships(df, columns)
        
        return DataCharacteristics(
            row_count=len(df),
            column_count=len(df.columns),
            columns=columns,
            numeric_columns=numeric_columns,
            categorical_columns=categorical_columns,
            temporal_columns=temporal_columns,
            data_complexity=data_complexity,
            relationships=relationships
        )
    
    def _determine_data_type(self, series: pd.Series) -> DataType:
        """确定数据类型"""
        # 检查是否为数值型
        if pd.api.types.is_numeric_dtype(series):
            return DataType.NUMERIC
        
        # 检查是否为时间型
        if pd.api.types.is_datetime64_any_dtype(series):
            return DataType.TEMPORAL
        
        # 尝试解析为日期时间
        if series.dtype == 'object':
            sample = series.dropna().head(10)
            if len(sample) > 0:
                try:
                    pd.to_datetime(sample.iloc[0])
                    return DataType.TEMPORAL
                except:
                    pass
        
        # 检查是否为布尔型
        if pd.api.types.is_bool_dtype(series) or series.nunique() == 2:
            unique_values = series.dropna().unique()
            if len(unique_values) == 2:
                return DataType.BOOLEAN
        
        # 检查是否为分类型
        unique_ratio = series.nunique() / len(series)
        if unique_ratio < 0.1 or series.nunique() < 20:
            return DataType.CATEGORICAL
        
        # 默认为文本型
        return DataType.TEXT
    
    def _calculate_column_statistics(self, series: pd.Series, data_type: DataType) -> Dict[str, Any]:
        """计算列统计信息"""
        stats = {}
        
        if data_type == DataType.NUMERIC:
            stats.update({
                'mean': series.mean(),
                'median': series.median(),
                'std': series.std(),
                'min': series.min(),
                'max': series.max(),
                'q25': series.quantile(0.25),
                'q75': series.quantile(0.75),
                'skewness': series.skew(),
                'kurtosis': series.kurtosis()
            })
        
        elif data_type == DataType.CATEGORICAL:
            value_counts = series.value_counts()
            stats.update({
                'most_frequent': value_counts.index[0] if len(value_counts) > 0 else None,
                'most_frequent_count': value_counts.iloc[0] if len(value_counts) > 0 else 0,
                'category_distribution': value_counts.head(10).to_dict()
            })
        
        elif data_type == DataType.TEMPORAL:
            stats.update({
                'min_date': series.min(),
                'max_date': series.max(),
                'date_range_days': (series.max() - series.min()).days if pd.notna(series.min()) and pd.notna(series.max()) else None
            })
        
        return stats
    
    def _assess_data_complexity(self, df: pd.DataFrame, columns: List[ColumnInfo]) -> str:
        """评估数据复杂度"""
        complexity_score = 0
        
        # 基于行数
        if len(df) > 10000:
            complexity_score += 2
        elif len(df) > 1000:
            complexity_score += 1
        
        # 基于列数
        if len(columns) > 10:
            complexity_score += 2
        elif len(columns) > 5:
            complexity_score += 1
        
        # 基于数据类型多样性
        data_types = set(col.data_type for col in columns)
        if len(data_types) > 3:
            complexity_score += 1
        
        # 基于唯一值比例
        high_cardinality_cols = sum(1 for col in columns if col.unique_count > len(df) * 0.8)
        if high_cardinality_cols > 0:
            complexity_score += 1
        
        if complexity_score >= 4:
            return "高"
        elif complexity_score >= 2:
            return "中"
        else:
            return "低"
    
    def _analyze_column_relationships(self, df: pd.DataFrame, columns: List[ColumnInfo]) -> List[Dict[str, Any]]:
        """分析列之间的关系"""
        relationships = []
        
        # 分析数值列之间的相关性
        numeric_cols = [col.name for col in columns if col.data_type == DataType.NUMERIC]
        if len(numeric_cols) > 1:
            correlation_matrix = df[numeric_cols].corr()
            
            for i, col1 in enumerate(numeric_cols):
                for j, col2 in enumerate(numeric_cols[i+1:], i+1):
                    correlation = correlation_matrix.loc[col1, col2]
                    if abs(correlation) > 0.5:  # 强相关性阈值
                        relationships.append({
                            'type': 'correlation',
                            'column1': col1,
                            'column2': col2,
                            'strength': abs(correlation),
                            'direction': 'positive' if correlation > 0 else 'negative'
                        })
        
        # 分析分类列与数值列的关系
        categorical_cols = [col.name for col in columns if col.data_type == DataType.CATEGORICAL]
        for cat_col in categorical_cols:
            for num_col in numeric_cols:
                # 简化的方差分析
                grouped = df.groupby(cat_col)[num_col].agg(['mean', 'std', 'count'])
                if len(grouped) > 1 and grouped['std'].mean() > 0:
                    variance_ratio = grouped['std'].max() / grouped['std'].min()
                    if variance_ratio > 2:  # 显著差异阈值
                        relationships.append({
                            'type': 'categorical_numeric',
                            'categorical_column': cat_col,
                            'numeric_column': num_col,
                            'variance_ratio': variance_ratio
                        })
        
        return relationships
    
    def _generate_chart_recommendations(self, characteristics: DataCharacteristics) -> List[ChartRecommendation]:
        """生成图表推荐"""
        recommendations = []
        
        # 基于数据特征应用推荐规则
        for rule in self.chart_rules:
            if self._rule_matches(rule, characteristics):
                recommendation = self._create_recommendation_from_rule(rule, characteristics)
                if recommendation:
                    recommendations.append(recommendation)
        
        # 按置信度排序
        recommendations.sort(key=lambda x: x.confidence, reverse=True)
        
        # 限制推荐数量
        return recommendations[:5]
    
    def _rule_matches(self, rule: Dict[str, Any], characteristics: DataCharacteristics) -> bool:
        """检查规则是否匹配"""
        conditions = rule.get('conditions', {})
        
        # 检查数值列数量
        if 'numeric_columns_min' in conditions:
            if len(characteristics.numeric_columns) < conditions['numeric_columns_min']:
                return False
        
        if 'numeric_columns_max' in conditions:
            if len(characteristics.numeric_columns) > conditions['numeric_columns_max']:
                return False
        
        # 检查分类列数量
        if 'categorical_columns_min' in conditions:
            if len(characteristics.categorical_columns) < conditions['categorical_columns_min']:
                return False
        
        if 'categorical_columns_max' in conditions:
            if len(characteristics.categorical_columns) > conditions['categorical_columns_max']:
                return False
        
        # 检查时间列
        if 'has_temporal' in conditions:
            has_temporal = len(characteristics.temporal_columns) > 0
            if conditions['has_temporal'] != has_temporal:
                return False
        
        # 检查数据量
        if 'row_count_min' in conditions:
            if characteristics.row_count < conditions['row_count_min']:
                return False
        
        if 'row_count_max' in conditions:
            if characteristics.row_count > conditions['row_count_max']:
                return False
        
        # 检查分类列的唯一值数量
        if 'categorical_unique_max' in conditions:
            for col in characteristics.columns:
                if col.data_type == DataType.CATEGORICAL:
                    if col.unique_count > conditions['categorical_unique_max']:
                        return False
        
        return True
    
    def _create_recommendation_from_rule(self, rule: Dict[str, Any], characteristics: DataCharacteristics) -> Optional[ChartRecommendation]:
        """从规则创建推荐"""
        chart_type = ChartType(rule['chart_type'])
        confidence = rule.get('confidence', 0.5)
        reason = rule.get('reason', '')
        
        # 确定轴映射
        x_axis, y_axis, color_by, size_by = self._determine_axis_mapping(
            chart_type, characteristics
        )
        
        if not x_axis and chart_type not in [ChartType.PIE, ChartType.CARD, ChartType.TABLE]:
            return None
        
        # 生成基础配置
        config = self._generate_base_config(chart_type, characteristics)
        
        return ChartRecommendation(
            chart_type=chart_type,
            confidence=confidence,
            reason=reason,
            config=config,
            x_axis=x_axis,
            y_axis=y_axis,
            color_by=color_by,
            size_by=size_by
        )
    
    def _determine_axis_mapping(self, chart_type: ChartType, characteristics: DataCharacteristics) -> Tuple[Optional[str], Optional[str], Optional[str], Optional[str]]:
        """确定轴映射"""
        x_axis = None
        y_axis = None
        color_by = None
        size_by = None
        
        numeric_cols = characteristics.numeric_columns
        categorical_cols = characteristics.categorical_columns
        temporal_cols = characteristics.temporal_columns
        
        if chart_type in [ChartType.BAR, ChartType.LINE, ChartType.AREA]:
            # 优先使用时间列作为X轴
            if temporal_cols:
                x_axis = temporal_cols[0]
                if numeric_cols:
                    y_axis = numeric_cols[0]
            # 其次使用分类列作为X轴
            elif categorical_cols:
                x_axis = categorical_cols[0]
                if numeric_cols:
                    y_axis = numeric_cols[0]
            # 最后使用数值列
            elif len(numeric_cols) >= 2:
                x_axis = numeric_cols[0]
                y_axis = numeric_cols[1]
            
            # 设置颜色分组
            if len(categorical_cols) > 1:
                color_by = categorical_cols[1] if categorical_cols[0] == x_axis else categorical_cols[0]
            elif len(categorical_cols) == 1 and categorical_cols[0] != x_axis:
                color_by = categorical_cols[0]
        
        elif chart_type == ChartType.SCATTER:
            if len(numeric_cols) >= 2:
                x_axis = numeric_cols[0]
                y_axis = numeric_cols[1]
                
                # 设置颜色和大小
                if categorical_cols:
                    color_by = categorical_cols[0]
                if len(numeric_cols) >= 3:
                    size_by = numeric_cols[2]
        
        elif chart_type == ChartType.PIE:
            if categorical_cols and numeric_cols:
                x_axis = categorical_cols[0]  # 分类
                y_axis = numeric_cols[0]      # 数值
        
        elif chart_type == ChartType.HISTOGRAM:
            if numeric_cols:
                x_axis = numeric_cols[0]
        
        elif chart_type == ChartType.BOX:
            if numeric_cols:
                y_axis = numeric_cols[0]
                if categorical_cols:
                    x_axis = categorical_cols[0]
        
        return x_axis, y_axis, color_by, size_by
    
    def _generate_base_config(self, chart_type: ChartType, characteristics: DataCharacteristics) -> Dict[str, Any]:
        """生成基础配置"""
        config = {
            'type': chart_type.value,
            'responsive': True,
            'maintainAspectRatio': False
        }
        
        # 根据图表类型添加特定配置
        if chart_type in [ChartType.BAR, ChartType.LINE, ChartType.AREA]:
            config.update({
                'scales': {
                    'x': {
                        'display': True,
                        'title': {
                            'display': True
                        }
                    },
                    'y': {
                        'display': True,
                        'title': {
                            'display': True
                        }
                    }
                },
                'plugins': {
                    'legend': {
                        'display': True,
                        'position': 'top'
                    },
                    'tooltip': {
                        'enabled': True
                    }
                }
            })
        
        elif chart_type == ChartType.PIE:
            config.update({
                'plugins': {
                    'legend': {
                        'display': True,
                        'position': 'right'
                    },
                    'tooltip': {
                        'enabled': True
                    }
                }
            })
        
        elif chart_type == ChartType.SCATTER:
            config.update({
                'scales': {
                    'x': {
                        'type': 'linear',
                        'position': 'bottom'
                    },
                    'y': {
                        'type': 'linear'
                    }
                }
            })
        
        # 添加颜色配置
        config['colors'] = self._select_color_palette(characteristics)
        
        return config
    
    def _select_color_palette(self, characteristics: DataCharacteristics) -> List[str]:
        """选择颜色调色板"""
        # 根据分类数量选择合适的调色板
        max_categories = 0
        for col in characteristics.columns:
            if col.data_type == DataType.CATEGORICAL:
                max_categories = max(max_categories, col.unique_count)
        
        if max_categories <= 3:
            return self.color_palettes['qualitative_3']
        elif max_categories <= 8:
            return self.color_palettes['qualitative_8']
        elif max_categories <= 12:
            return self.color_palettes['qualitative_12']
        else:
            return self.color_palettes['sequential']
    
    async def _enhance_recommendations_with_llm(self, 
                                              recommendations: List[ChartRecommendation],
                                              characteristics: DataCharacteristics,
                                              sql_query: str = None,
                                              context: Dict[str, Any] = None) -> List[ChartRecommendation]:
        """使用LLM增强推荐"""
        if not self.llm_client or not recommendations:
            return recommendations
        
        prompt = f"""
请分析以下数据特征并优化可视化推荐：

数据特征：
- 行数：{characteristics.row_count}
- 列数：{characteristics.column_count}
- 数值列：{characteristics.numeric_columns}
- 分类列：{characteristics.categorical_columns}
- 时间列：{characteristics.temporal_columns}
- 数据复杂度：{characteristics.data_complexity}

SQL查询：{sql_query or '未提供'}

业务上下文：{json.dumps(context, ensure_ascii=False) if context else '未提供'}

当前推荐：
{json.dumps([{'type': rec.chart_type.value, 'confidence': rec.confidence, 'reason': rec.reason} for rec in recommendations], ensure_ascii=False, indent=2)}

请提供：
1. 对当前推荐的评估和改进建议
2. 是否有更适合的图表类型
3. 可视化的业务价值说明

请以JSON格式返回优化后的推荐列表。
"""
        
        try:
            response = await self.llm_client.generate_response(prompt)
            # 解析LLM响应并更新推荐
            enhanced_data = json.loads(response)
            
            # 更新推荐理由和置信度
            for i, rec in enumerate(recommendations):
                if i < len(enhanced_data.get('recommendations', [])):
                    enhanced_rec = enhanced_data['recommendations'][i]
                    rec.reason = enhanced_rec.get('reason', rec.reason)
                    rec.confidence = min(enhanced_rec.get('confidence', rec.confidence), 1.0)
            
            return recommendations
            
        except Exception as e:
            logger.error(f"LLM增强推荐失败: {e}")
            return recommendations
    
    def _generate_visualization_configs(self, 
                                      recommendations: List[ChartRecommendation],
                                      characteristics: DataCharacteristics) -> Dict[str, Any]:
        """生成可视化配置"""
        configs = {}
        
        for i, rec in enumerate(recommendations):
            config_key = f"{rec.chart_type.value}_{i+1}"
            
            # 生成完整的图表配置
            full_config = {
                'chart_type': rec.chart_type.value,
                'data_mapping': {
                    'x': rec.x_axis,
                    'y': rec.y_axis,
                    'color': rec.color_by,
                    'size': rec.size_by
                },
                'chart_config': rec.config,
                'title': self._generate_chart_title(rec, characteristics),
                'description': rec.reason,
                'confidence': rec.confidence
            }
            
            # 添加特定图表类型的配置
            if rec.chart_type == ChartType.TABLE:
                full_config['table_config'] = self._generate_table_config(characteristics)
            elif rec.chart_type == ChartType.CARD:
                full_config['card_config'] = self._generate_card_config(characteristics)
            
            configs[config_key] = full_config
        
        return configs
    
    def _generate_chart_title(self, recommendation: ChartRecommendation, characteristics: DataCharacteristics) -> str:
        """生成图表标题"""
        chart_type = recommendation.chart_type
        
        if chart_type == ChartType.BAR:
            if recommendation.x_axis and recommendation.y_axis:
                return f"{recommendation.y_axis} 按 {recommendation.x_axis} 分布"
        elif chart_type == ChartType.LINE:
            if recommendation.x_axis and recommendation.y_axis:
                return f"{recommendation.y_axis} 随 {recommendation.x_axis} 变化趋势"
        elif chart_type == ChartType.PIE:
            if recommendation.x_axis and recommendation.y_axis:
                return f"{recommendation.y_axis} 在 {recommendation.x_axis} 中的占比"
        elif chart_type == ChartType.SCATTER:
            if recommendation.x_axis and recommendation.y_axis:
                return f"{recommendation.x_axis} 与 {recommendation.y_axis} 的关系"
        
        return f"数据{chart_type.value}图"
    
    def _generate_table_config(self, characteristics: DataCharacteristics) -> Dict[str, Any]:
        """生成表格配置"""
        return {
            'pagination': characteristics.row_count > 100,
            'page_size': min(50, characteristics.row_count),
            'sortable': True,
            'filterable': True,
            'searchable': characteristics.row_count > 20,
            'export_enabled': True
        }
    
    def _generate_card_config(self, characteristics: DataCharacteristics) -> Dict[str, Any]:
        """生成卡片配置"""
        # 选择最重要的指标显示
        primary_metric = None
        if characteristics.numeric_columns:
            primary_metric = characteristics.numeric_columns[0]
        
        return {
            'primary_metric': primary_metric,
            'show_trend': len(characteristics.temporal_columns) > 0,
            'show_comparison': len(characteristics.numeric_columns) > 1,
            'format': 'number' if primary_metric else 'text'
        }
    
    def _generate_best_practices(self, 
                               recommendations: List[ChartRecommendation],
                               characteristics: DataCharacteristics) -> List[Dict[str, Any]]:
        """生成最佳实践建议"""
        practices = []
        
        # 基于数据量的建议
        if characteristics.row_count > 10000:
            practices.append({
                'category': 'performance',
                'title': '大数据量优化',
                'description': '数据量较大，建议使用数据采样或分页显示',
                'priority': 'high'
            })
        
        # 基于列数的建议
        if characteristics.column_count > 10:
            practices.append({
                'category': 'layout',
                'title': '多列数据处理',
                'description': '列数较多，建议使用表格视图或分组显示',
                'priority': 'medium'
            })
        
        # 基于分类列的建议
        high_cardinality_cats = [
            col for col in characteristics.columns 
            if col.data_type == DataType.CATEGORICAL and col.unique_count > 20
        ]
        if high_cardinality_cats:
            practices.append({
                'category': 'data_preparation',
                'title': '高基数分类处理',
                'description': f'分类列 {[col.name for col in high_cardinality_cats]} 的唯一值过多，建议进行分组或筛选',
                'priority': 'medium'
            })
        
        # 基于图表类型的建议
        for rec in recommendations:
            if rec.chart_type == ChartType.PIE and rec.x_axis:
                # 检查饼图的分类数量
                cat_col = next((col for col in characteristics.columns if col.name == rec.x_axis), None)
                if cat_col and cat_col.unique_count > 8:
                    practices.append({
                        'category': 'chart_design',
                        'title': '饼图分类优化',
                        'description': '饼图分类过多，建议合并小分类或使用柱状图',
                        'priority': 'medium'
                    })
        
        # 颜色和可访问性建议
        practices.append({
            'category': 'accessibility',
            'title': '颜色可访问性',
            'description': '确保图表颜色对色盲用户友好，建议使用形状或纹理辅助区分',
            'priority': 'low'
        })
        
        # 响应式设计建议
        practices.append({
            'category': 'responsive',
            'title': '响应式设计',
            'description': '确保图表在不同设备上的显示效果，建议设置合适的尺寸和字体',
            'priority': 'medium'
        })
        
        return practices
    
    def _load_chart_rules(self) -> List[Dict[str, Any]]:
        """加载图表推荐规则"""
        return [
            {
                'chart_type': 'bar',
                'conditions': {
                    'categorical_columns_min': 1,
                    'numeric_columns_min': 1,
                    'categorical_unique_max': 20
                },
                'confidence': 0.8,
                'reason': '适合展示分类数据的数值比较'
            },
            {
                'chart_type': 'line',
                'conditions': {
                    'has_temporal': True,
                    'numeric_columns_min': 1
                },
                'confidence': 0.9,
                'reason': '适合展示时间序列数据的趋势变化'
            },
            {
                'chart_type': 'pie',
                'conditions': {
                    'categorical_columns_min': 1,
                    'numeric_columns_min': 1,
                    'categorical_unique_max': 8
                },
                'confidence': 0.7,
                'reason': '适合展示部分与整体的占比关系'
            },
            {
                'chart_type': 'scatter',
                'conditions': {
                    'numeric_columns_min': 2
                },
                'confidence': 0.8,
                'reason': '适合展示两个数值变量之间的关系'
            },
            {
                'chart_type': 'histogram',
                'conditions': {
                    'numeric_columns_min': 1,
                    'row_count_min': 50
                },
                'confidence': 0.6,
                'reason': '适合展示数值数据的分布情况'
            },
            {
                'chart_type': 'box',
                'conditions': {
                    'numeric_columns_min': 1,
                    'categorical_columns_min': 1
                },
                'confidence': 0.7,
                'reason': '适合展示不同分组的数值分布和异常值'
            },
            {
                'chart_type': 'table',
                'conditions': {
                    'row_count_max': 1000
                },
                'confidence': 0.5,
                'reason': '适合展示详细的原始数据'
            },
            {
                'chart_type': 'card',
                'conditions': {
                    'numeric_columns_min': 1,
                    'row_count_max': 1
                },
                'confidence': 0.9,
                'reason': '适合展示单一关键指标'
            }
        ]
    
    def _load_color_palettes(self) -> Dict[str, List[str]]:
        """加载颜色调色板"""
        return {
            'qualitative_3': ['#1f77b4', '#ff7f0e', '#2ca02c'],
            'qualitative_8': [
                '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728',
                '#9467bd', '#8c564b', '#e377c2', '#7f7f7f'
            ],
            'qualitative_12': [
                '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728',
                '#9467bd', '#8c564b', '#e377c2', '#7f7f7f',
                '#bcbd22', '#17becf', '#aec7e8', '#ffbb78'
            ],
            'sequential': [
                '#f7fbff', '#deebf7', '#c6dbef', '#9ecae1',
                '#6baed6', '#4292c6', '#2171b5', '#08519c', '#08306b'
            ],
            'diverging': [
                '#8c510a', '#bf812d', '#dfc27d', '#f6e8c3',
                '#f5f5f5', '#c7eae5', '#80cdc1', '#35978f', '#01665e'
            ]
        }
    
    def _load_chart_templates(self) -> Dict[str, Dict[str, Any]]:
        """加载图表模板"""
        return {
            'bar': {
                'layout': {
                    'title': '',
                    'xaxis': {'title': ''},
                    'yaxis': {'title': ''}
                }
            },
            'line': {
                'layout': {
                    'title': '',
                    'xaxis': {'title': ''},
                    'yaxis': {'title': ''}
                }
            },
            'pie': {
                'layout': {
                    'title': ''
                }
            },
            'scatter': {
                'layout': {
                    'title': '',
                    'xaxis': {'title': ''},
                    'yaxis': {'title': ''}
                }
            }
        }
```

## API接口

### REST API

```python
from fastapi import APIRouter, HTTPException, Depends, UploadFile, File
from pydantic import BaseModel
from typing import Optional, Dict, Any, List
import pandas as pd
import io

router = APIRouter()

class VisualizationRequest(BaseModel):
    data: List[Dict[str, Any]]  # 查询结果数据
    sql_query: Optional[str] = None
    context: Optional[Dict[str, Any]] = None

class ChartConfigRequest(BaseModel):
    chart_type: str
    data: List[Dict[str, Any]]
    x_axis: Optional[str] = None
    y_axis: Optional[str] = None
    color_by: Optional[str] = None
    size_by: Optional[str] = None

@router.post("/recommend")
async def recommend_visualizations(
    request: VisualizationRequest,
    recommender: VisualizationRecommenderAgent = Depends(get_visualization_recommender)
):
    """推荐可视化方案"""
    try:
        # 转换数据为DataFrame
        df = pd.DataFrame(request.data)
        
        if df.empty:
            raise HTTPException(status_code=400, detail="数据为空")
        
        result = await recommender.recommend_visualizations(
            df, request.sql_query, request.context
        )
        
        return result
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/generate-config")
async def generate_chart_config(
    request: ChartConfigRequest,
    recommender: VisualizationRecommenderAgent = Depends(get_visualization_recommender)
):
    """生成特定图表配置"""
    try:
        df = pd.DataFrame(request.data)
        
        # 分析数据特征
        characteristics = recommender._analyze_data_characteristics(df)
        
        # 创建推荐
        chart_type = ChartType(request.chart_type)
        recommendation = ChartRecommendation(
            chart_type=chart_type,
            confidence=1.0,
            reason="用户指定的图表类型",
            config=recommender._generate_base_config(chart_type, characteristics),
            x_axis=request.x_axis,
            y_axis=request.y_axis,
            color_by=request.color_by,
            size_by=request.size_by
        )
        
        # 生成配置
        configs = recommender._generate_visualization_configs([recommendation], characteristics)
        
        return {
            'success': True,
            'config': list(configs.values())[0] if configs else None
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/upload-data")
async def upload_data_for_visualization(
    file: UploadFile = File(...),
    recommender: VisualizationRecommenderAgent = Depends(get_visualization_recommender)
):
    """上传数据文件进行可视化推荐"""
    try:
        # 读取文件内容
        content = await file.read()
        
        # 根据文件类型解析数据
        if file.filename.endswith('.csv'):
            df = pd.read_csv(io.StringIO(content.decode('utf-8')))
        elif file.filename.endswith('.xlsx'):
            df = pd.read_excel(io.BytesIO(content))
        else:
            raise HTTPException(status_code=400, detail="不支持的文件格式")
        
        # 限制数据量
        if len(df) > 10000:
            df = df.head(10000)
        
        result = await recommender.recommend_visualizations(df)
        
        return result
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/chart-types")
async def get_supported_chart_types():
    """获取支持的图表类型"""
    return {
        'chart_types': [
            {
                'type': chart_type.value,
                'name': chart_type.value.title(),
                'description': get_chart_description(chart_type)
            }
            for chart_type in ChartType
        ]
    }

@router.get("/color-palettes")
async def get_color_palettes(
    recommender: VisualizationRecommenderAgent = Depends(get_visualization_recommender)
):
    """获取可用的颜色调色板"""
    return {
        'palettes': recommender.color_palettes
    }

def get_chart_description(chart_type: ChartType) -> str:
    """获取图表类型描述"""
    descriptions = {
        ChartType.BAR: "柱状图，适合比较分类数据",
        ChartType.LINE: "折线图，适合展示趋势变化",
        ChartType.PIE: "饼图，适合展示占比关系",
        ChartType.SCATTER: "散点图，适合展示相关性",
        ChartType.AREA: "面积图，适合展示累积数据",
        ChartType.HISTOGRAM: "直方图，适合展示数据分布",
        ChartType.BOX: "箱线图，适合展示数据分布和异常值",
        ChartType.HEATMAP: "热力图，适合展示矩阵数据",
        ChartType.TREEMAP: "树状图，适合展示层次数据",
        ChartType.GAUGE: "仪表盘，适合展示单一指标",
        ChartType.TABLE: "表格，适合展示详细数据",
        ChartType.CARD: "卡片，适合展示关键指标"
    }
    return descriptions.get(chart_type, "")
```

## 测试用例

```python
import pytest
import pandas as pd
from unittest.mock import AsyncMock, MagicMock
import numpy as np

class TestVisualizationRecommenderAgent:
    @pytest.fixture
    def sample_data(self):
        return pd.DataFrame({
            'category': ['A', 'B', 'C', 'A', 'B', 'C'],
            'value': [10, 20, 15, 12, 18, 17],
            'date': pd.date_range('2023-01-01', periods=6),
            'score': [85, 92, 78, 88, 95, 82]
        })
    
    @pytest.fixture
    def recommender(self):
        return VisualizationRecommenderAgent()
    
    def test_analyze_data_characteristics(self, recommender, sample_data):
        """测试数据特征分析"""
        characteristics = recommender._analyze_data_characteristics(sample_data)
        
        assert characteristics.row_count == 6
        assert characteristics.column_count == 4
        assert 'value' in characteristics.numeric_columns
        assert 'score' in characteristics.numeric_columns
        assert 'category' in characteristics.categorical_columns
        assert 'date' in characteristics.temporal_columns
    
    def test_determine_data_type(self, recommender):
        """测试数据类型判断"""
        # 数值型
        numeric_series = pd.Series([1, 2, 3, 4, 5])
        assert recommender._determine_data_type(numeric_series) == DataType.NUMERIC
        
        # 分类型
        categorical_series = pd.Series(['A', 'B', 'A', 'C', 'B'])
        assert recommender._determine_data_type(categorical_series) == DataType.CATEGORICAL
        
        # 时间型
        temporal_series = pd.Series(pd.date_range('2023-01-01', periods=5))
        assert recommender._determine_data_type(temporal_series) == DataType.TEMPORAL
        
        # 布尔型
        boolean_series = pd.Series([True, False, True, False])
        assert recommender._determine_data_type(boolean_series) == DataType.BOOLEAN
    
    def test_generate_chart_recommendations(self, recommender, sample_data):
        """测试图表推荐生成"""
        characteristics = recommender._analyze_data_characteristics(sample_data)
        recommendations = recommender._generate_chart_recommendations(characteristics)
        
        assert len(recommendations) > 0
        assert all(isinstance(rec, ChartRecommendation) for rec in recommendations)
        assert all(0 <= rec.confidence <= 1 for rec in recommendations)
    
    def test_rule_matches(self, recommender, sample_data):
        """测试规则匹配"""
        characteristics = recommender._analyze_data_characteristics(sample_data)
        
        # 测试柱状图规则
        bar_rule = {
            'conditions': {
                'categorical_columns_min': 1,
                'numeric_columns_min': 1,
                'categorical_unique_max': 20
            }
        }
        assert recommender._rule_matches(bar_rule, characteristics)
        
        # 测试折线图规则
        line_rule = {
            'conditions': {
                'has_temporal': True,
                'numeric_columns_min': 1
            }
        }
        assert recommender._rule_matches(line_rule, characteristics)
    
    def test_determine_axis_mapping(self, recommender, sample_data):
        """测试轴映射确定"""
        characteristics = recommender._analyze_data_characteristics(sample_data)
        
        # 测试柱状图轴映射
        x_axis, y_axis, color_by, size_by = recommender._determine_axis_mapping(
            ChartType.BAR, characteristics
        )
        assert x_axis is not None
        assert y_axis is not None
        
        # 测试散点图轴映射
        x_axis, y_axis, color_by, size_by = recommender._determine_axis_mapping(
            ChartType.SCATTER, characteristics
        )
        assert x_axis in characteristics.numeric_columns
        assert y_axis in characteristics.numeric_columns
    
    def test_select_color_palette(self, recommender, sample_data):
        """测试颜色调色板选择"""
        characteristics = recommender._analyze_data_characteristics(sample_data)
        colors = recommender._select_color_palette(characteristics)
        
        assert isinstance(colors, list)
        assert len(colors) > 0
        assert all(isinstance(color, str) for color in colors)
    
    @pytest.mark.asyncio
    async def test_recommend_visualizations(self, recommender, sample_data):
        """测试完整的可视化推荐流程"""
        result = await recommender.recommend_visualizations(sample_data)
        
        assert result['success']
        assert 'data_characteristics' in result
        assert 'recommendations' in result
        assert 'visualization_configs' in result
        assert 'best_practices' in result
        
        # 检查推荐结果
        recommendations = result['recommendations']
        assert len(recommendations) > 0
        
        # 检查配置
        configs = result['visualization_configs']
        assert len(configs) > 0
    
    def test_generate_chart_title(self, recommender, sample_data):
        """测试图表标题生成"""
        characteristics = recommender._analyze_data_characteristics(sample_data)
        
        recommendation = ChartRecommendation(
            chart_type=ChartType.BAR,
            confidence=0.8,
            reason="测试",
            config={},
            x_axis='category',
            y_axis='value'
        )
        
        title = recommender._generate_chart_title(recommendation, characteristics)
        assert isinstance(title, str)
        assert len(title) > 0
    
    def test_generate_best_practices(self, recommender, sample_data):
        """测试最佳实践建议生成"""
        characteristics = recommender._analyze_data_characteristics(sample_data)
        recommendations = [ChartRecommendation(
            chart_type=ChartType.BAR,
            confidence=0.8,
            reason="测试",
            config={}
        )]
        
        practices = recommender._generate_best_practices(recommendations, characteristics)
        
        assert isinstance(practices, list)
        for practice in practices:
            assert 'category' in practice
            assert 'title' in practice
            assert 'description' in practice
            assert 'priority' in practice

class TestVisualizationAPI:
    @pytest.fixture
    def client(self):
        from fastapi.testclient import TestClient
        from main import app  # 假设主应用在main.py中
        return TestClient(app)
    
    def test_recommend_visualizations_endpoint(self, client):
        """测试可视化推荐API端点"""
        data = [
            {'category': 'A', 'value': 10},
            {'category': 'B', 'value': 20},
            {'category': 'C', 'value': 15}
        ]
        
        response = client.post("/visualization/recommend", json={
            'data': data,
            'sql_query': 'SELECT category, value FROM test_table'
        })
        
        assert response.status_code == 200
        result = response.json()
        assert result['success']
        assert 'recommendations' in result
    
    def test_generate_config_endpoint(self, client):
        """测试图表配置生成API端点"""
        data = [
            {'x': 1, 'y': 10},
            {'x': 2, 'y': 20},
            {'x': 3, 'y': 15}
        ]
        
        response = client.post("/visualization/generate-config", json={
            'chart_type': 'scatter',
            'data': data,
            'x_axis': 'x',
            'y_axis': 'y'
        })
        
        assert response.status_code == 200
        result = response.json()
        assert result['success']
        assert 'config' in result
    
    def test_get_chart_types_endpoint(self, client):
        """测试获取图表类型API端点"""
        response = client.get("/visualization/chart-types")
        
        assert response.status_code == 200
        result = response.json()
        assert 'chart_types' in result
        assert len(result['chart_types']) > 0
```

---

*此文档提供了可视化推荐服务的完整实现指南，包括数据特征分析、智能图表推荐、配置生成和最佳实践建议功能。*