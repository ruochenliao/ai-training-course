# 流式响应与通信服务功能还原提示词

## 服务概述

流式响应与通信服务负责Text2SQL系统中的实时数据传输和用户交互，通过WebSocket连接提供流式响应能力，支持查询处理过程的实时反馈、进度更新、结果推送和错误处理。该服务确保用户能够实时了解查询处理状态，提供良好的交互体验。

## 核心功能

### 1. WebSocket连接管理
- WebSocket连接的建立、维护和断开
- 连接状态监控和自动重连机制
- 多客户端连接的并发管理
- 连接认证和权限验证

### 2. 流式消息处理
- 实时消息的发送和接收
- 消息的序列化和反序列化
- 消息队列和缓冲机制
- 消息的优先级和路由管理

### 3. 查询进度跟踪
- 查询处理各阶段的进度反馈
- 实时状态更新和错误通知
- 处理时间估算和剩余时间预测
- 取消和中断操作支持

### 4. 结果流式传输
- 大数据集的分块传输
- 增量结果的实时推送
- 数据压缩和传输优化
- 断点续传和错误恢复

## 技术实现

### WebSocket连接管理器

```python
from fastapi import WebSocket, WebSocketDisconnect
from typing import Dict, List, Optional, Any, Callable
import asyncio
import json
import uuid
import time
import logging
from datetime import datetime
from enum import Enum
from dataclasses import dataclass, asdict
from concurrent.futures import ThreadPoolExecutor
import weakref

logger = logging.getLogger(__name__)

class MessageType(Enum):
    """消息类型枚举"""
    QUERY_START = "query_start"
    QUERY_PROGRESS = "query_progress"
    QUERY_RESULT = "query_result"
    QUERY_ERROR = "query_error"
    QUERY_COMPLETE = "query_complete"
    QUERY_CANCEL = "query_cancel"
    SYSTEM_STATUS = "system_status"
    USER_FEEDBACK = "user_feedback"
    HEARTBEAT = "heartbeat"
    CONNECTION_ACK = "connection_ack"

class QueryStage(Enum):
    """查询处理阶段"""
    ANALYZING = "analyzing"
    RETRIEVING_SCHEMA = "retrieving_schema"
    GENERATING_SQL = "generating_sql"
    VALIDATING_SQL = "validating_sql"
    EXECUTING_SQL = "executing_sql"
    PROCESSING_RESULTS = "processing_results"
    GENERATING_EXPLANATION = "generating_explanation"
    RECOMMENDING_VISUALIZATION = "recommending_visualization"
    COMPLETED = "completed"
    ERROR = "error"
    CANCELLED = "cancelled"

@dataclass
class StreamMessage:
    """流式消息数据结构"""
    type: MessageType
    session_id: str
    timestamp: datetime
    data: Dict[str, Any]
    message_id: Optional[str] = None
    user_id: Optional[int] = None
    
    def __post_init__(self):
        if self.message_id is None:
            self.message_id = str(uuid.uuid4())
    
    def to_dict(self) -> Dict[str, Any]:
        """转换为字典格式"""
        result = asdict(self)
        result['type'] = self.type.value
        result['timestamp'] = self.timestamp.isoformat()
        return result
    
    def to_json(self) -> str:
        """转换为JSON字符串"""
        return json.dumps(self.to_dict(), ensure_ascii=False)

@dataclass
class QueryProgress:
    """查询进度信息"""
    stage: QueryStage
    progress: int  # 0-100
    message: str
    details: Optional[Dict[str, Any]] = None
    estimated_time_remaining: Optional[int] = None  # 秒
    
    def to_dict(self) -> Dict[str, Any]:
        result = asdict(self)
        result['stage'] = self.stage.value
        return result

class ConnectionManager:
    """WebSocket连接管理器"""
    
    def __init__(self):
        # 活跃连接：session_id -> WebSocket
        self.active_connections: Dict[str, WebSocket] = {}
        # 用户会话映射：user_id -> List[session_id]
        self.user_sessions: Dict[int, List[str]] = {}
        # 会话信息：session_id -> session_info
        self.session_info: Dict[str, Dict[str, Any]] = {}
        # 消息队列：session_id -> List[StreamMessage]
        self.message_queues: Dict[str, List[StreamMessage]] = {}
        # 心跳监控
        self.last_heartbeat: Dict[str, float] = {}
        # 线程池用于异步任务
        self.executor = ThreadPoolExecutor(max_workers=10)
        # 启动心跳检查任务
        asyncio.create_task(self._heartbeat_monitor())
    
    async def connect(self, websocket: WebSocket, session_id: str, user_id: int) -> bool:
        """建立WebSocket连接"""
        try:
            await websocket.accept()
            
            # 如果会话已存在，断开旧连接
            if session_id in self.active_connections:
                await self.disconnect(session_id, "New connection established")
            
            # 注册新连接
            self.active_connections[session_id] = websocket
            
            # 更新用户会话映射
            if user_id not in self.user_sessions:
                self.user_sessions[user_id] = []
            if session_id not in self.user_sessions[user_id]:
                self.user_sessions[user_id].append(session_id)
            
            # 保存会话信息
            self.session_info[session_id] = {
                'user_id': user_id,
                'connected_at': datetime.utcnow(),
                'last_activity': time.time()
            }
            
            # 初始化消息队列
            self.message_queues[session_id] = []
            
            # 更新心跳时间
            self.last_heartbeat[session_id] = time.time()
            
            # 发送连接确认消息
            await self.send_message(session_id, StreamMessage(
                type=MessageType.CONNECTION_ACK,
                session_id=session_id,
                timestamp=datetime.utcnow(),
                data={
                    'status': 'connected',
                    'session_id': session_id,
                    'server_time': datetime.utcnow().isoformat()
                },
                user_id=user_id
            ))
            
            logger.info(f"WebSocket连接建立: session_id={session_id}, user_id={user_id}")
            return True
            
        except Exception as e:
            logger.error(f"WebSocket连接失败: {e}")
            return False
    
    async def disconnect(self, session_id: str, reason: str = "Connection closed"):
        """断开WebSocket连接"""
        try:
            if session_id in self.active_connections:
                websocket = self.active_connections[session_id]
                
                # 发送断开连接消息
                try:
                    await websocket.send_text(json.dumps({
                        'type': 'connection_close',
                        'reason': reason,
                        'timestamp': datetime.utcnow().isoformat()
                    }))
                except:
                    pass  # 连接可能已经断开
                
                # 关闭WebSocket连接
                try:
                    await websocket.close()
                except:
                    pass
                
                # 清理连接信息
                del self.active_connections[session_id]
            
            # 清理会话信息
            if session_id in self.session_info:
                user_id = self.session_info[session_id].get('user_id')
                if user_id and user_id in self.user_sessions:
                    if session_id in self.user_sessions[user_id]:
                        self.user_sessions[user_id].remove(session_id)
                    if not self.user_sessions[user_id]:
                        del self.user_sessions[user_id]
                
                del self.session_info[session_id]
            
            # 清理消息队列
            if session_id in self.message_queues:
                del self.message_queues[session_id]
            
            # 清理心跳记录
            if session_id in self.last_heartbeat:
                del self.last_heartbeat[session_id]
            
            logger.info(f"WebSocket连接断开: session_id={session_id}, reason={reason}")
            
        except Exception as e:
            logger.error(f"断开WebSocket连接失败: {e}")
    
    async def send_message(self, session_id: str, message: StreamMessage) -> bool:
        """发送消息到指定会话"""
        try:
            if session_id not in self.active_connections:
                logger.warning(f"会话不存在: {session_id}")
                return False
            
            websocket = self.active_connections[session_id]
            
            # 发送消息
            await websocket.send_text(message.to_json())
            
            # 更新最后活动时间
            if session_id in self.session_info:
                self.session_info[session_id]['last_activity'] = time.time()
            
            # 记录消息到队列（用于调试和重发）
            if session_id in self.message_queues:
                self.message_queues[session_id].append(message)
                # 限制队列大小
                if len(self.message_queues[session_id]) > 100:
                    self.message_queues[session_id] = self.message_queues[session_id][-50:]
            
            return True
            
        except WebSocketDisconnect:
            logger.info(f"WebSocket连接已断开: {session_id}")
            await self.disconnect(session_id, "Client disconnected")
            return False
        except Exception as e:
            logger.error(f"发送消息失败: {e}")
            return False
    
    async def broadcast_to_user(self, user_id: int, message: StreamMessage) -> int:
        """向用户的所有会话广播消息"""
        sent_count = 0
        
        if user_id in self.user_sessions:
            for session_id in self.user_sessions[user_id].copy():
                if await self.send_message(session_id, message):
                    sent_count += 1
        
        return sent_count
    
    async def broadcast_to_all(self, message: StreamMessage) -> int:
        """向所有活跃连接广播消息"""
        sent_count = 0
        
        for session_id in list(self.active_connections.keys()):
            if await self.send_message(session_id, message):
                sent_count += 1
        
        return sent_count
    
    async def receive_message(self, session_id: str) -> Optional[Dict[str, Any]]:
        """接收来自客户端的消息"""
        try:
            if session_id not in self.active_connections:
                return None
            
            websocket = self.active_connections[session_id]
            data = await websocket.receive_text()
            
            # 更新最后活动时间
            if session_id in self.session_info:
                self.session_info[session_id]['last_activity'] = time.time()
            
            # 更新心跳时间
            self.last_heartbeat[session_id] = time.time()
            
            return json.loads(data)
            
        except WebSocketDisconnect:
            logger.info(f"WebSocket连接断开: {session_id}")
            await self.disconnect(session_id, "Client disconnected")
            return None
        except json.JSONDecodeError as e:
            logger.error(f"JSON解析失败: {e}")
            return None
        except Exception as e:
            logger.error(f"接收消息失败: {e}")
            return None
    
    def get_active_sessions(self) -> List[str]:
        """获取所有活跃会话ID"""
        return list(self.active_connections.keys())
    
    def get_user_sessions(self, user_id: int) -> List[str]:
        """获取用户的所有会话ID"""
        return self.user_sessions.get(user_id, [])
    
    def get_session_info(self, session_id: str) -> Optional[Dict[str, Any]]:
        """获取会话信息"""
        return self.session_info.get(session_id)
    
    def get_connection_stats(self) -> Dict[str, Any]:
        """获取连接统计信息"""
        return {
            'total_connections': len(self.active_connections),
            'total_users': len(self.user_sessions),
            'sessions_per_user': {
                user_id: len(sessions) 
                for user_id, sessions in self.user_sessions.items()
            },
            'average_sessions_per_user': (
                sum(len(sessions) for sessions in self.user_sessions.values()) / 
                len(self.user_sessions) if self.user_sessions else 0
            )
        }
    
    async def _heartbeat_monitor(self):
        """心跳监控任务"""
        while True:
            try:
                current_time = time.time()
                timeout_sessions = []
                
                # 检查超时的会话
                for session_id, last_heartbeat in self.last_heartbeat.items():
                    if current_time - last_heartbeat > 60:  # 60秒超时
                        timeout_sessions.append(session_id)
                
                # 断开超时的会话
                for session_id in timeout_sessions:
                    await self.disconnect(session_id, "Heartbeat timeout")
                
                # 发送心跳消息
                heartbeat_message = StreamMessage(
                    type=MessageType.HEARTBEAT,
                    session_id="server",
                    timestamp=datetime.utcnow(),
                    data={'server_time': datetime.utcnow().isoformat()}
                )
                
                await self.broadcast_to_all(heartbeat_message)
                
                # 等待30秒后再次检查
                await asyncio.sleep(30)
                
            except Exception as e:
                logger.error(f"心跳监控错误: {e}")
                await asyncio.sleep(30)

# 全局连接管理器实例
connection_manager = ConnectionManager()
```

### 流式查询处理器

```python
from typing import AsyncGenerator, Callable, Any
import asyncio
from contextlib import asynccontextmanager

class StreamingQueryProcessor:
    """流式查询处理器"""
    
    def __init__(self, connection_manager: ConnectionManager):
        self.connection_manager = connection_manager
        self.active_queries: Dict[str, Dict[str, Any]] = {}
        self.query_callbacks: Dict[str, List[Callable]] = {}
    
    async def process_query(self, 
                          session_id: str,
                          query: str,
                          user_id: int,
                          database_config: Dict[str, Any],
                          options: Dict[str, Any] = None) -> str:
        """处理流式查询"""
        query_id = str(uuid.uuid4())
        
        try:
            # 注册查询
            self.active_queries[query_id] = {
                'session_id': session_id,
                'user_id': user_id,
                'query': query,
                'database_config': database_config,
                'options': options or {},
                'start_time': datetime.utcnow(),
                'status': 'running',
                'current_stage': QueryStage.ANALYZING
            }
            
            # 发送查询开始消息
            await self._send_query_message(session_id, MessageType.QUERY_START, {
                'query_id': query_id,
                'query': query,
                'start_time': datetime.utcnow().isoformat()
            })
            
            # 异步处理查询
            asyncio.create_task(self._execute_query_pipeline(query_id))
            
            return query_id
            
        except Exception as e:
            logger.error(f"启动查询处理失败: {e}")
            await self._send_query_message(session_id, MessageType.QUERY_ERROR, {
                'query_id': query_id,
                'error': str(e),
                'stage': 'initialization'
            })
            raise
    
    async def cancel_query(self, query_id: str, session_id: str) -> bool:
        """取消查询"""
        try:
            if query_id not in self.active_queries:
                return False
            
            query_info = self.active_queries[query_id]
            
            # 检查权限
            if query_info['session_id'] != session_id:
                return False
            
            # 更新状态
            query_info['status'] = 'cancelled'
            query_info['current_stage'] = QueryStage.CANCELLED
            
            # 发送取消消息
            await self._send_query_message(session_id, MessageType.QUERY_CANCEL, {
                'query_id': query_id,
                'cancelled_at': datetime.utcnow().isoformat()
            })
            
            # 清理查询信息
            del self.active_queries[query_id]
            
            logger.info(f"查询已取消: {query_id}")
            return True
            
        except Exception as e:
            logger.error(f"取消查询失败: {e}")
            return False
    
    async def _execute_query_pipeline(self, query_id: str):
        """执行查询处理流水线"""
        try:
            query_info = self.active_queries[query_id]
            session_id = query_info['session_id']
            
            # 检查查询是否被取消
            if query_info['status'] == 'cancelled':
                return
            
            # 阶段1: 查询分析
            await self._update_progress(query_id, QueryStage.ANALYZING, 10, "分析自然语言查询...")
            analysis_result = await self._analyze_query(query_info['query'])
            
            if query_info['status'] == 'cancelled':
                return
            
            # 阶段2: 检索数据库模式
            await self._update_progress(query_id, QueryStage.RETRIEVING_SCHEMA, 25, "检索数据库模式信息...")
            schema_info = await self._retrieve_schema(query_info['database_config'], analysis_result)
            
            if query_info['status'] == 'cancelled':
                return
            
            # 阶段3: 生成SQL
            await self._update_progress(query_id, QueryStage.GENERATING_SQL, 45, "生成SQL查询语句...")
            sql_result = await self._generate_sql(analysis_result, schema_info)
            
            if query_info['status'] == 'cancelled':
                return
            
            # 阶段4: 验证SQL
            await self._update_progress(query_id, QueryStage.VALIDATING_SQL, 55, "验证SQL语句...")
            validation_result = await self._validate_sql(sql_result['sql'], query_info['database_config'])
            
            if query_info['status'] == 'cancelled':
                return
            
            # 阶段5: 执行SQL
            await self._update_progress(query_id, QueryStage.EXECUTING_SQL, 70, "执行SQL查询...")
            execution_result = await self._execute_sql(sql_result['sql'], query_info['database_config'])
            
            if query_info['status'] == 'cancelled':
                return
            
            # 阶段6: 处理结果
            await self._update_progress(query_id, QueryStage.PROCESSING_RESULTS, 80, "处理查询结果...")
            processed_result = await self._process_results(execution_result)
            
            if query_info['status'] == 'cancelled':
                return
            
            # 阶段7: 生成解释
            await self._update_progress(query_id, QueryStage.GENERATING_EXPLANATION, 90, "生成SQL解释...")
            explanation = await self._generate_explanation(sql_result['sql'], processed_result)
            
            if query_info['status'] == 'cancelled':
                return
            
            # 阶段8: 推荐可视化
            await self._update_progress(query_id, QueryStage.RECOMMENDING_VISUALIZATION, 95, "推荐数据可视化...")
            visualization = await self._recommend_visualization(processed_result)
            
            if query_info['status'] == 'cancelled':
                return
            
            # 完成查询
            await self._update_progress(query_id, QueryStage.COMPLETED, 100, "查询处理完成")
            
            # 发送最终结果
            await self._send_query_message(session_id, MessageType.QUERY_COMPLETE, {
                'query_id': query_id,
                'sql': sql_result['sql'],
                'results': processed_result,
                'explanation': explanation,
                'visualization': visualization,
                'execution_time': (datetime.utcnow() - query_info['start_time']).total_seconds(),
                'completed_at': datetime.utcnow().isoformat()
            })
            
            # 清理查询信息
            query_info['status'] = 'completed'
            
        except Exception as e:
            logger.error(f"查询处理失败: {e}")
            await self._send_query_message(query_info['session_id'], MessageType.QUERY_ERROR, {
                'query_id': query_id,
                'error': str(e),
                'stage': query_info['current_stage'].value,
                'error_time': datetime.utcnow().isoformat()
            })
            
            # 更新状态
            query_info['status'] = 'error'
            query_info['current_stage'] = QueryStage.ERROR
    
    async def _update_progress(self, query_id: str, stage: QueryStage, progress: int, message: str):
        """更新查询进度"""
        try:
            if query_id not in self.active_queries:
                return
            
            query_info = self.active_queries[query_id]
            query_info['current_stage'] = stage
            
            progress_info = QueryProgress(
                stage=stage,
                progress=progress,
                message=message
            )
            
            await self._send_query_message(query_info['session_id'], MessageType.QUERY_PROGRESS, {
                'query_id': query_id,
                'progress': progress_info.to_dict(),
                'timestamp': datetime.utcnow().isoformat()
            })
            
        except Exception as e:
            logger.error(f"更新进度失败: {e}")
    
    async def _send_query_message(self, session_id: str, message_type: MessageType, data: Dict[str, Any]):
        """发送查询相关消息"""
        message = StreamMessage(
            type=message_type,
            session_id=session_id,
            timestamp=datetime.utcnow(),
            data=data
        )
        
        await self.connection_manager.send_message(session_id, message)
    
    # 以下方法需要根据实际的服务实现
    async def _analyze_query(self, query: str) -> Dict[str, Any]:
        """分析查询（调用智能查询分析服务）"""
        # 模拟异步处理
        await asyncio.sleep(1)
        return {'entities': [], 'intent': 'select', 'keywords': []}
    
    async def _retrieve_schema(self, db_config: Dict[str, Any], analysis: Dict[str, Any]) -> Dict[str, Any]:
        """检索数据库模式（调用数据库模式检索服务）"""
        await asyncio.sleep(1)
        return {'tables': [], 'columns': [], 'relationships': []}
    
    async def _generate_sql(self, analysis: Dict[str, Any], schema: Dict[str, Any]) -> Dict[str, Any]:
        """生成SQL（调用SQL生成服务）"""
        await asyncio.sleep(2)
        return {'sql': 'SELECT * FROM table', 'confidence': 0.9}
    
    async def _validate_sql(self, sql: str, db_config: Dict[str, Any]) -> Dict[str, Any]:
        """验证SQL（调用SQL验证服务）"""
        await asyncio.sleep(0.5)
        return {'valid': True, 'warnings': []}
    
    async def _execute_sql(self, sql: str, db_config: Dict[str, Any]) -> Dict[str, Any]:
        """执行SQL（调用SQL执行服务）"""
        await asyncio.sleep(2)
        return {'data': [], 'columns': [], 'row_count': 0}
    
    async def _process_results(self, execution_result: Dict[str, Any]) -> Dict[str, Any]:
        """处理结果（调用结果处理服务）"""
        await asyncio.sleep(0.5)
        return execution_result
    
    async def _generate_explanation(self, sql: str, results: Dict[str, Any]) -> Dict[str, Any]:
        """生成解释（调用SQL解释服务）"""
        await asyncio.sleep(1)
        return {'explanation': 'SQL explanation', 'complexity': 'medium'}
    
    async def _recommend_visualization(self, results: Dict[str, Any]) -> Dict[str, Any]:
        """推荐可视化（调用可视化推荐服务）"""
        await asyncio.sleep(0.5)
        return {'chart_type': 'table', 'config': {}}
    
    def get_active_queries(self) -> Dict[str, Dict[str, Any]]:
        """获取活跃查询列表"""
        return self.active_queries.copy()
    
    def get_query_info(self, query_id: str) -> Optional[Dict[str, Any]]:
        """获取查询信息"""
        return self.active_queries.get(query_id)
```

### WebSocket端点实现

```python
from fastapi import APIRouter, WebSocket, WebSocketDisconnect, Depends, HTTPException
from fastapi.security import HTTPBearer
import json

router = APIRouter()
security = HTTPBearer()

# 全局查询处理器
query_processor = StreamingQueryProcessor(connection_manager)

@router.websocket("/text2sql/websocket")
async def text2sql_websocket(websocket: WebSocket, session_id: str = None, token: str = None):
    """Text2SQL WebSocket端点"""
    
    # 生成会话ID
    if not session_id:
        session_id = str(uuid.uuid4())
    
    # 验证用户身份（简化版本）
    user_id = await verify_token(token) if token else 1  # 默认用户ID
    
    # 建立连接
    if not await connection_manager.connect(websocket, session_id, user_id):
        return
    
    try:
        while True:
            # 接收客户端消息
            message_data = await connection_manager.receive_message(session_id)
            
            if message_data is None:
                break
            
            # 处理不同类型的消息
            await handle_client_message(session_id, user_id, message_data)
            
    except WebSocketDisconnect:
        logger.info(f"WebSocket客户端断开连接: {session_id}")
    except Exception as e:
        logger.error(f"WebSocket处理错误: {e}")
    finally:
        await connection_manager.disconnect(session_id, "Connection ended")

async def handle_client_message(session_id: str, user_id: int, message_data: Dict[str, Any]):
    """处理客户端消息"""
    try:
        message_type = message_data.get('type')
        data = message_data.get('data', {})
        
        if message_type == 'query_request':
            # 处理查询请求
            query = data.get('query')
            database_config = data.get('database_config', {})
            options = data.get('options', {})
            
            if not query:
                await connection_manager.send_message(session_id, StreamMessage(
                    type=MessageType.QUERY_ERROR,
                    session_id=session_id,
                    timestamp=datetime.utcnow(),
                    data={'error': '查询内容不能为空'},
                    user_id=user_id
                ))
                return
            
            # 启动查询处理
            query_id = await query_processor.process_query(
                session_id=session_id,
                query=query,
                user_id=user_id,
                database_config=database_config,
                options=options
            )
            
        elif message_type == 'query_cancel':
            # 处理查询取消
            query_id = data.get('query_id')
            if query_id:
                await query_processor.cancel_query(query_id, session_id)
        
        elif message_type == 'heartbeat':
            # 处理心跳消息
            await connection_manager.send_message(session_id, StreamMessage(
                type=MessageType.HEARTBEAT,
                session_id=session_id,
                timestamp=datetime.utcnow(),
                data={'status': 'alive'},
                user_id=user_id
            ))
        
        elif message_type == 'user_feedback':
            # 处理用户反馈
            feedback = data.get('feedback')
            query_id = data.get('query_id')
            
            # 记录用户反馈（可以用于改进系统）
            logger.info(f"用户反馈: query_id={query_id}, feedback={feedback}")
            
            await connection_manager.send_message(session_id, StreamMessage(
                type=MessageType.USER_FEEDBACK,
                session_id=session_id,
                timestamp=datetime.utcnow(),
                data={'status': 'received', 'message': '感谢您的反馈'},
                user_id=user_id
            ))
        
        else:
            logger.warning(f"未知消息类型: {message_type}")
            
    except Exception as e:
        logger.error(f"处理客户端消息失败: {e}")
        await connection_manager.send_message(session_id, StreamMessage(
            type=MessageType.QUERY_ERROR,
            session_id=session_id,
            timestamp=datetime.utcnow(),
            data={'error': f'处理消息失败: {str(e)}'},
            user_id=user_id
        ))

async def verify_token(token: str) -> int:
    """验证用户令牌并返回用户ID"""
    # 这里应该实现实际的令牌验证逻辑
    # 简化版本直接返回用户ID
    return 1

# 管理端点
@router.get("/text2sql/connections")
async def get_connections(current_user_id: int = Depends(get_current_user_id)):
    """获取连接统计信息"""
    return connection_manager.get_connection_stats()

@router.get("/text2sql/queries")
async def get_active_queries(current_user_id: int = Depends(get_current_user_id)):
    """获取活跃查询列表"""
    return query_processor.get_active_queries()

@router.post("/text2sql/broadcast")
async def broadcast_message(
    message: str,
    message_type: str = "system_status",
    current_user_id: int = Depends(get_current_user_id)
):
    """广播系统消息"""
    broadcast_message = StreamMessage(
        type=MessageType.SYSTEM_STATUS,
        session_id="system",
        timestamp=datetime.utcnow(),
        data={'message': message, 'type': message_type}
    )
    
    sent_count = await connection_manager.broadcast_to_all(broadcast_message)
    
    return {
        'message': '消息已广播',
        'sent_to': sent_count,
        'total_connections': len(connection_manager.get_active_sessions())
    }
```

## 前端集成示例

```typescript
// WebSocket客户端类
class Text2SQLWebSocketClient {
    private ws: WebSocket | null = null;
    private sessionId: string;
    private reconnectAttempts = 0;
    private maxReconnectAttempts = 5;
    private reconnectDelay = 1000;
    private messageHandlers: Map<string, Function[]> = new Map();
    
    constructor(private baseUrl: string, private token?: string) {
        this.sessionId = this.generateSessionId();
    }
    
    connect(): Promise<void> {
        return new Promise((resolve, reject) => {
            try {
                const wsUrl = `${this.baseUrl}/text2sql/websocket?session_id=${this.sessionId}${this.token ? `&token=${this.token}` : ''}`;
                this.ws = new WebSocket(wsUrl);
                
                this.ws.onopen = () => {
                    console.log('WebSocket连接已建立');
                    this.reconnectAttempts = 0;
                    resolve();
                };
                
                this.ws.onmessage = (event) => {
                    this.handleMessage(JSON.parse(event.data));
                };
                
                this.ws.onclose = (event) => {
                    console.log('WebSocket连接已关闭', event.code, event.reason);
                    this.attemptReconnect();
                };
                
                this.ws.onerror = (error) => {
                    console.error('WebSocket错误:', error);
                    reject(error);
                };
                
            } catch (error) {
                reject(error);
            }
        });
    }
    
    disconnect(): void {
        if (this.ws) {
            this.ws.close();
            this.ws = null;
        }
    }
    
    sendQuery(query: string, databaseConfig: any, options: any = {}): void {
        this.sendMessage({
            type: 'query_request',
            data: {
                query,
                database_config: databaseConfig,
                options
            }
        });
    }
    
    cancelQuery(queryId: string): void {
        this.sendMessage({
            type: 'query_cancel',
            data: { query_id: queryId }
        });
    }
    
    sendFeedback(queryId: string, feedback: any): void {
        this.sendMessage({
            type: 'user_feedback',
            data: {
                query_id: queryId,
                feedback
            }
        });
    }
    
    private sendMessage(message: any): void {
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            this.ws.send(JSON.stringify(message));
        } else {
            console.error('WebSocket未连接');
        }
    }
    
    private handleMessage(message: any): void {
        const { type, data } = message;
        
        // 触发对应的消息处理器
        const handlers = this.messageHandlers.get(type) || [];
        handlers.forEach(handler => {
            try {
                handler(data, message);
            } catch (error) {
                console.error('消息处理器错误:', error);
            }
        });
    }
    
    on(messageType: string, handler: Function): void {
        if (!this.messageHandlers.has(messageType)) {
            this.messageHandlers.set(messageType, []);
        }
        this.messageHandlers.get(messageType)!.push(handler);
    }
    
    off(messageType: string, handler?: Function): void {
        if (!handler) {
            this.messageHandlers.delete(messageType);
        } else {
            const handlers = this.messageHandlers.get(messageType) || [];
            const index = handlers.indexOf(handler);
            if (index > -1) {
                handlers.splice(index, 1);
            }
        }
    }
    
    private attemptReconnect(): void {
        if (this.reconnectAttempts < this.maxReconnectAttempts) {
            this.reconnectAttempts++;
            console.log(`尝试重连 (${this.reconnectAttempts}/${this.maxReconnectAttempts})...`);
            
            setTimeout(() => {
                this.connect().catch(error => {
                    console.error('重连失败:', error);
                });
            }, this.reconnectDelay * this.reconnectAttempts);
        } else {
            console.error('达到最大重连次数，停止重连');
        }
    }
    
    private generateSessionId(): string {
        return 'session_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
    }
}

// React Hook示例
function useText2SQLWebSocket(baseUrl: string, token?: string) {
    const [client, setClient] = useState<Text2SQLWebSocketClient | null>(null);
    const [isConnected, setIsConnected] = useState(false);
    const [queryResults, setQueryResults] = useState<any[]>([]);
    const [queryProgress, setQueryProgress] = useState<any>(null);
    
    useEffect(() => {
        const wsClient = new Text2SQLWebSocketClient(baseUrl, token);
        
        // 注册消息处理器
        wsClient.on('connection_ack', () => {
            setIsConnected(true);
        });
        
        wsClient.on('query_progress', (data) => {
            setQueryProgress(data);
        });
        
        wsClient.on('query_result', (data) => {
            setQueryResults(prev => [...prev, data]);
        });
        
        wsClient.on('query_complete', (data) => {
            setQueryProgress(null);
            setQueryResults(prev => [...prev, data]);
        });
        
        wsClient.on('query_error', (data) => {
            setQueryProgress(null);
            console.error('查询错误:', data);
        });
        
        // 连接WebSocket
        wsClient.connect().then(() => {
            setClient(wsClient);
        }).catch(error => {
            console.error('WebSocket连接失败:', error);
        });
        
        return () => {
            wsClient.disconnect();
            setIsConnected(false);
        };
    }, [baseUrl, token]);
    
    const sendQuery = useCallback((query: string, databaseConfig: any, options?: any) => {
        if (client) {
            client.sendQuery(query, databaseConfig, options);
        }
    }, [client]);
    
    const cancelQuery = useCallback((queryId: string) => {
        if (client) {
            client.cancelQuery(queryId);
        }
    }, [client]);
    
    return {
        isConnected,
        queryResults,
        queryProgress,
        sendQuery,
        cancelQuery,
        client
    };
}
```

## 测试用例

```python
import pytest
import asyncio
from fastapi.testclient import TestClient
from fastapi.websockets import WebSocket
from unittest.mock import AsyncMock, MagicMock, patch
import json

class TestConnectionManager:
    @pytest.fixture
    def connection_manager(self):
        return ConnectionManager()
    
    @pytest.mark.asyncio
    async def test_connect_and_disconnect(self, connection_manager):
        """测试连接建立和断开"""
        # 模拟WebSocket
        mock_websocket = AsyncMock(spec=WebSocket)
        session_id = "test_session_1"
        user_id = 1
        
        # 测试连接
        result = await connection_manager.connect(mock_websocket, session_id, user_id)
        assert result == True
        assert session_id in connection_manager.active_connections
        assert user_id in connection_manager.user_sessions
        
        # 验证连接确认消息
        mock_websocket.send_text.assert_called()
        
        # 测试断开连接
        await connection_manager.disconnect(session_id)
        assert session_id not in connection_manager.active_connections
        assert user_id not in connection_manager.user_sessions
    
    @pytest.mark.asyncio
    async def test_send_message(self, connection_manager):
        """测试消息发送"""
        mock_websocket = AsyncMock(spec=WebSocket)
        session_id = "test_session_2"
        user_id = 1
        
        # 建立连接
        await connection_manager.connect(mock_websocket, session_id, user_id)
        
        # 发送消息
        message = StreamMessage(
            type=MessageType.QUERY_START,
            session_id=session_id,
            timestamp=datetime.utcnow(),
            data={'test': 'data'}
        )
        
        result = await connection_manager.send_message(session_id, message)
        assert result == True
        
        # 验证WebSocket发送调用
        assert mock_websocket.send_text.call_count >= 2  # 连接确认 + 测试消息
    
    @pytest.mark.asyncio
    async def test_broadcast_to_user(self, connection_manager):
        """测试用户广播"""
        user_id = 1
        
        # 为同一用户建立多个会话
        sessions = []
        for i in range(3):
            mock_websocket = AsyncMock(spec=WebSocket)
            session_id = f"test_session_{i}"
            await connection_manager.connect(mock_websocket, session_id, user_id)
            sessions.append((session_id, mock_websocket))
        
        # 广播消息
        message = StreamMessage(
            type=MessageType.SYSTEM_STATUS,
            session_id="system",
            timestamp=datetime.utcnow(),
            data={'broadcast': 'test'}
        )
        
        sent_count = await connection_manager.broadcast_to_user(user_id, message)
        assert sent_count == 3
        
        # 验证所有会话都收到消息
        for session_id, mock_websocket in sessions:
            assert mock_websocket.send_text.call_count >= 2
    
    def test_connection_stats(self, connection_manager):
        """测试连接统计"""
        stats = connection_manager.get_connection_stats()
        
        assert 'total_connections' in stats
        assert 'total_users' in stats
        assert 'sessions_per_user' in stats
        assert 'average_sessions_per_user' in stats

class TestStreamingQueryProcessor:
    @pytest.fixture
    def query_processor(self):
        mock_connection_manager = MagicMock(spec=ConnectionManager)
        return StreamingQueryProcessor(mock_connection_manager)
    
    @pytest.mark.asyncio
    async def test_process_query(self, query_processor):
        """测试查询处理"""
        session_id = "test_session"
        query = "SELECT * FROM users"
        user_id = 1
        database_config = {'type': 'mysql', 'host': 'localhost'}
        
        # 模拟异步方法
        with patch.multiple(
            query_processor,
            _analyze_query=AsyncMock(return_value={'intent': 'select'}),
            _retrieve_schema=AsyncMock(return_value={'tables': ['users']}),
            _generate_sql=AsyncMock(return_value={'sql': 'SELECT * FROM users'}),
            _validate_sql=AsyncMock(return_value={'valid': True}),
            _execute_sql=AsyncMock(return_value={'data': [], 'columns': []}),
            _process_results=AsyncMock(return_value={'processed': True}),
            _generate_explanation=AsyncMock(return_value={'explanation': 'test'}),
            _recommend_visualization=AsyncMock(return_value={'chart_type': 'table'})
        ):
            query_id = await query_processor.process_query(
                session_id, query, user_id, database_config
            )
            
            assert query_id is not None
            assert query_id in query_processor.active_queries
            
            # 等待查询处理完成
            await asyncio.sleep(0.1)
            
            # 验证连接管理器的发送消息调用
            assert query_processor.connection_manager.send_message.called
    
    @pytest.mark.asyncio
    async def test_cancel_query(self, query_processor):
        """测试查询取消"""
        session_id = "test_session"
        query_id = "test_query_id"
        
        # 添加活跃查询
        query_processor.active_queries[query_id] = {
            'session_id': session_id,
            'status': 'running',
            'current_stage': QueryStage.ANALYZING
        }
        
        result = await query_processor.cancel_query(query_id, session_id)
        assert result == True
        assert query_id not in query_processor.active_queries
    
    def test_get_query_info(self, query_processor):
        """测试获取查询信息"""
        query_id = "test_query_id"
        query_info = {
            'session_id': 'test_session',
            'status': 'running'
        }
        
        query_processor.active_queries[query_id] = query_info
        
        result = query_processor.get_query_info(query_id)
        assert result == query_info
        
        # 测试不存在的查询
        result = query_processor.get_query_info("nonexistent")
        assert result is None

class TestWebSocketEndpoint:
    @pytest.fixture
    def client(self):
        from fastapi.testclient import TestClient
        from main import app  # 假设主应用在main.py中
        return TestClient(app)
    
    def test_websocket_connection(self, client):
        """测试WebSocket连接"""
        with client.websocket_connect("/text2sql/websocket?session_id=test") as websocket:
            # 应该收到连接确认消息
            data = websocket.receive_json()
            assert data['type'] == 'connection_ack'
    
    def test_query_request(self, client):
        """测试查询请求"""
        with client.websocket_connect("/text2sql/websocket?session_id=test") as websocket:
            # 跳过连接确认消息
            websocket.receive_json()
            
            # 发送查询请求
            websocket.send_json({
                'type': 'query_request',
                'data': {
                    'query': 'SELECT * FROM users',
                    'database_config': {'type': 'mysql'}
                }
            })
            
            # 应该收到查询开始消息
            data = websocket.receive_json()
            assert data['type'] == 'query_start'
    
    def test_heartbeat(self, client):
        """测试心跳消息"""
        with client.websocket_connect("/text2sql/websocket?session_id=test") as websocket:
            # 跳过连接确认消息
            websocket.receive_json()
            
            # 发送心跳消息
            websocket.send_json({
                'type': 'heartbeat',
                'data': {}
            })
            
            # 应该收到心跳响应
            data = websocket.receive_json()
            assert data['type'] == 'heartbeat'
            assert data['data']['status'] == 'alive'
    
    def test_invalid_message(self, client):
        """测试无效消息处理"""
        with client.websocket_connect("/text2sql/websocket?session_id=test") as websocket:
            # 跳过连接确认消息
            websocket.receive_json()
            
            # 发送空查询请求
            websocket.send_json({
                'type': 'query_request',
                'data': {
                    'query': '',  # 空查询
                    'database_config': {}
                }
            })
            
            # 应该收到错误消息
            data = websocket.receive_json()
            assert data['type'] == 'query_error'
            assert '不能为空' in data['data']['error']

class TestMessageTypes:
    def test_stream_message_creation(self):
        """测试流式消息创建"""
        message = StreamMessage(
            type=MessageType.QUERY_START,
            session_id="test_session",
            timestamp=datetime.utcnow(),
            data={'test': 'data'},
            user_id=1
        )
        
        assert message.message_id is not None
        assert message.type == MessageType.QUERY_START
        assert message.user_id == 1
    
    def test_stream_message_serialization(self):
        """测试流式消息序列化"""
        message = StreamMessage(
            type=MessageType.QUERY_PROGRESS,
            session_id="test_session",
            timestamp=datetime.utcnow(),
            data={'progress': 50}
        )
        
        # 测试转换为字典
        message_dict = message.to_dict()
        assert message_dict['type'] == 'query_progress'
        assert message_dict['data']['progress'] == 50
        
        # 测试转换为JSON
        message_json = message.to_json()
        parsed = json.loads(message_json)
        assert parsed['type'] == 'query_progress'
    
    def test_query_progress_creation(self):
        """测试查询进度创建"""
        progress = QueryProgress(
            stage=QueryStage.GENERATING_SQL,
            progress=75,
            message="正在生成SQL...",
            estimated_time_remaining=30
        )
        
        progress_dict = progress.to_dict()
        assert progress_dict['stage'] == 'generating_sql'
        assert progress_dict['progress'] == 75
        assert progress_dict['estimated_time_remaining'] == 30
```

---

*此文档提供了流式响应与通信服务的完整实现指南，包括WebSocket连接管理、流式消息处理、查询进度跟踪和前端集成示例。*